{
  "ast": null,
  "code": "/*\r\n\r\n\r\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/FR');\n\nvar DAYS_OFFSET = util.WEEKDAY_OFFSET;\nvar PATTERN = new RegExp('(\\\\W|^)' + '(?:(Dimanche|Lundi|Mardi|mercredi|Jeudi|Vendredi|Samedi|Dim|Lun|Mar|Mer|Jeu|Ven|Sam)\\\\s*,?\\\\s*)?' + '([0-9]{1,2}|1er)' + '(?:\\\\s*(?:au|\\\\-|\\\\–|jusqu\\'au?|\\\\s)\\\\s*([0-9]{1,2})(?:er)?)?\\\\s*(?:de)?\\\\s*' + '(Jan(?:vier|\\\\.)?|F[ée]v(?:rier|\\\\.)?|Mars|Avr(?:il|\\\\.)?|Mai|Juin|Juil(?:let|\\\\.)?|Ao[uû]t|Sept(?:embre|\\\\.)?|Oct(?:obre|\\\\.)?|Nov(?:embre|\\\\.)?|d[ée]c(?:embre|\\\\.)?)' + '(?:\\\\s*(\\\\s*[0-9]{1,4}(?![^\\\\s]\\\\d))(?:\\\\s*(AC|[ap]\\\\.?\\\\s*c(?:h(?:r)?)?\\\\.?\\\\s*n\\\\.?))?)?' + '(?=\\\\W|$)', 'i');\nvar WEEKDAY_GROUP = 2;\nvar DATE_GROUP = 3;\nvar DATE_TO_GROUP = 4;\nvar MONTH_NAME_GROUP = 5;\nvar YEAR_GROUP = 6;\nvar YEAR_BE_GROUP = 7;\n\nexports.Parser = function FRMonthNameLittleEndianParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var result = new ParsedResult({\n      text: match[0].substr(match[1].length, match[0].length - match[1].length),\n      index: match.index + match[1].length,\n      ref: ref\n    });\n    var month = match[MONTH_NAME_GROUP];\n    month = util.MONTH_OFFSET[month.toLowerCase()];\n    var day = match[DATE_GROUP];\n    day = parseInt(day);\n    var year = null;\n\n    if (match[YEAR_GROUP]) {\n      year = match[YEAR_GROUP];\n      year = parseInt(year);\n\n      if (match[YEAR_BE_GROUP]) {\n        if (/a/i.test(match[YEAR_BE_GROUP])) {\n          // Ante Christe natum\n          year = -year;\n        }\n      } else if (year < 100) {\n        year = year + 2000;\n      }\n    }\n\n    if (year) {\n      result.start.assign('day', day);\n      result.start.assign('month', month);\n      result.start.assign('year', year);\n    } else {\n      // Find the most appropriated year\n      var refMoment = moment(ref);\n      refMoment.month(month - 1);\n      refMoment.date(day);\n      refMoment.year(moment(ref).year());\n      var nextYear = refMoment.clone().add(1, 'y');\n      var lastYear = refMoment.clone().add(-1, 'y');\n\n      if (Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = nextYear;\n      } else if (Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = lastYear;\n      }\n\n      result.start.assign('day', day);\n      result.start.assign('month', month);\n      result.start.imply('year', refMoment.year());\n    } // Weekday component\n\n\n    if (match[WEEKDAY_GROUP]) {\n      var weekday = match[WEEKDAY_GROUP];\n      weekday = util.WEEKDAY_OFFSET[weekday.toLowerCase()];\n      result.start.assign('weekday', weekday);\n    } // Text can be 'range' value. Such as '12 - 13 janvier 2012'\n\n\n    if (match[DATE_TO_GROUP]) {\n      result.end = result.start.clone();\n      result.end.assign('day', parseInt(match[DATE_TO_GROUP]));\n    }\n\n    result.tags['FRMonthNameLittleEndianParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/fr/FRMonthNameLittleEndianParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "util",
      "DAYS_OFFSET",
      "WEEKDAY_OFFSET",
      "PATTERN",
      "RegExp",
      "WEEKDAY_GROUP",
      "DATE_GROUP",
      "DATE_TO_GROUP",
      "MONTH_NAME_GROUP",
      "YEAR_GROUP",
      "YEAR_BE_GROUP",
      "exports",
      "FRMonthNameLittleEndianParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "result",
      "substr",
      "length",
      "index",
      "month",
      "MONTH_OFFSET",
      "toLowerCase",
      "day",
      "parseInt",
      "year",
      "test",
      "start",
      "assign",
      "refMoment",
      "date",
      "nextYear",
      "clone",
      "add",
      "lastYear",
      "Math",
      "abs",
      "diff",
      "imply",
      "weekday",
      "end",
      "tags"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\r\n\r\n\r\n*/\r\n\r\nvar moment = require('moment');\r\n\r\nvar Parser = require('../parser').Parser;\r\nvar ParsedResult = require('../../result').ParsedResult;\r\n\r\nvar util  = require('../../utils/FR');\r\n\r\nvar DAYS_OFFSET = util.WEEKDAY_OFFSET;\r\n\r\nvar PATTERN = new RegExp('(\\\\W|^)' +\r\n        '(?:(Dimanche|Lundi|Mardi|mercredi|Jeudi|Vendredi|Samedi|Dim|Lun|Mar|Mer|Jeu|Ven|Sam)\\\\s*,?\\\\s*)?' +\r\n        '([0-9]{1,2}|1er)' +\r\n        '(?:\\\\s*(?:au|\\\\-|\\\\–|jusqu\\'au?|\\\\s)\\\\s*([0-9]{1,2})(?:er)?)?\\\\s*(?:de)?\\\\s*' +\r\n        '(Jan(?:vier|\\\\.)?|F[ée]v(?:rier|\\\\.)?|Mars|Avr(?:il|\\\\.)?|Mai|Juin|Juil(?:let|\\\\.)?|Ao[uû]t|Sept(?:embre|\\\\.)?|Oct(?:obre|\\\\.)?|Nov(?:embre|\\\\.)?|d[ée]c(?:embre|\\\\.)?)' +\r\n        '(?:\\\\s*(\\\\s*[0-9]{1,4}(?![^\\\\s]\\\\d))(?:\\\\s*(AC|[ap]\\\\.?\\\\s*c(?:h(?:r)?)?\\\\.?\\\\s*n\\\\.?))?)?' +\r\n        '(?=\\\\W|$)', 'i'\r\n    );\r\n\r\nvar WEEKDAY_GROUP = 2;\r\nvar DATE_GROUP = 3;\r\nvar DATE_TO_GROUP = 4;\r\nvar MONTH_NAME_GROUP = 5;\r\nvar YEAR_GROUP = 6;\r\nvar YEAR_BE_GROUP = 7;\r\n\r\nexports.Parser = function FRMonthNameLittleEndianParser(){\r\n    Parser.apply(this, arguments);\r\n\r\n    this.pattern = function() { return PATTERN; }\r\n\r\n    this.extract = function(text, ref, match, opt){\r\n\r\n        var result = new ParsedResult({\r\n            text: match[0].substr(match[1].length, match[0].length - match[1].length),\r\n            index: match.index + match[1].length,\r\n            ref: ref,\r\n        });\r\n\r\n        var month = match[MONTH_NAME_GROUP];\r\n        month = util.MONTH_OFFSET[month.toLowerCase()];\r\n\r\n        var day = match[DATE_GROUP];\r\n        day = parseInt(day);\r\n\r\n        var year = null;\r\n        if (match[YEAR_GROUP]) {\r\n            year = match[YEAR_GROUP];\r\n            year = parseInt(year);\r\n\r\n            if(match[YEAR_BE_GROUP]){\r\n                if (/a/i.test(match[YEAR_BE_GROUP])) {\r\n                    // Ante Christe natum\r\n                    year = -year;\r\n                }\r\n            } else if (year < 100){\r\n\r\n                year = year + 2000;\r\n            }\r\n        }\r\n\r\n        if(year){\r\n            result.start.assign('day', day);\r\n            result.start.assign('month', month);\r\n            result.start.assign('year', year);\r\n        } else {\r\n\r\n            // Find the most appropriated year\r\n            var refMoment = moment(ref);\r\n            refMoment.month(month - 1);\r\n            refMoment.date(day);\r\n            refMoment.year(moment(ref).year());\r\n\r\n            var nextYear = refMoment.clone().add(1, 'y');\r\n            var lastYear = refMoment.clone().add(-1, 'y');\r\n            if( Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref))) ){\r\n                refMoment = nextYear;\r\n            }\r\n            else if( Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref))) ){\r\n                refMoment = lastYear;\r\n            }\r\n\r\n            result.start.assign('day', day);\r\n            result.start.assign('month', month);\r\n            result.start.imply('year', refMoment.year());\r\n        }\r\n\r\n        // Weekday component\r\n        if (match[WEEKDAY_GROUP]) {\r\n            var weekday = match[WEEKDAY_GROUP];\r\n            weekday = util.WEEKDAY_OFFSET[weekday.toLowerCase()]\r\n            result.start.assign('weekday', weekday);\r\n        }\r\n\r\n        // Text can be 'range' value. Such as '12 - 13 janvier 2012'\r\n        if (match[DATE_TO_GROUP]) {\r\n            result.end = result.start.clone();\r\n            result.end.assign('day', parseInt(match[DATE_TO_GROUP]));\r\n        }\r\n\r\n        result.tags['FRMonthNameLittleEndianParser'] = true;\r\n        return result;\r\n    };\r\n}\r\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

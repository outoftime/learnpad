{
  "ast": null,
  "code": "/*\n    \n    The parser for parsing month name and year.\n    \n    EX. \n        - Januar\n        - Januar 2012\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/DE');\n\nvar PATTERN = new RegExp('(^|\\\\D\\\\s+|[^\\\\w\\\\s])' + '(Jan\\\\.?|Januar|Feb\\\\.?|Februar|M채r\\\\.?|M(?:채|ae)rz|Mrz\\\\.?|Apr\\\\.?|April|Mai\\\\.?|Jun\\\\.?|Juni|Jul\\\\.?|Juli|Aug\\\\.?|August|Sep\\\\.?|Sept\\\\.?|September|Okt\\\\.?|Oktober|Nov\\\\.?|November|Dez\\\\.?|Dezember)' + '\\\\s*' + '(?:' + ',?\\\\s*(?:([0-9]{4})(\\\\s*[vn]\\\\.?\\\\s*C(?:hr)?\\\\.?)?|([0-9]{1,4})\\\\s*([vn]\\\\.?\\\\s*C(?:hr)?\\\\.?))' + ')?' + '(?=[^\\\\s\\\\w]|$)', 'i');\nvar MONTH_NAME_GROUP = 2;\nvar YEAR_GROUP = 3;\nvar YEAR_BE_GROUP = 4;\nvar YEAR_GROUP2 = 5;\nvar YEAR_BE_GROUP2 = 6;\n\nexports.Parser = function ENMonthNameParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var result = new ParsedResult({\n      text: match[0].substr(match[1].length, match[0].length - match[1].length),\n      index: match.index + match[1].length,\n      ref: ref\n    });\n    var month = match[MONTH_NAME_GROUP];\n    month = util.MONTH_OFFSET[month.toLowerCase()];\n    var day = 1;\n    var year = null;\n\n    if (match[YEAR_GROUP] || match[YEAR_GROUP2]) {\n      year = match[YEAR_GROUP] || match[YEAR_GROUP2];\n      year = parseInt(year);\n\n      if (match[YEAR_BE_GROUP] || match[YEAR_BE_GROUP2]) {\n        if (/v/i.test(match[YEAR_BE_GROUP] || match[YEAR_BE_GROUP2])) {\n          // v.Chr.\n          year = -year;\n        }\n      } else if (year < 100) {\n        year = year + 2000;\n      }\n    }\n\n    if (year) {\n      result.start.imply('day', day);\n      result.start.assign('month', month);\n      result.start.assign('year', year);\n    } else {\n      //Find the most appropriated year\n      var refMoment = moment(ref);\n      refMoment.month(month - 1);\n      refMoment.date(day);\n      var nextYear = refMoment.clone().add(1, 'y');\n      var lastYear = refMoment.clone().add(-1, 'y');\n\n      if (Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = nextYear;\n      } else if (Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = lastYear;\n      }\n\n      result.start.imply('day', day);\n      result.start.assign('month', month);\n      result.start.imply('year', refMoment.year());\n    }\n\n    result.tags['DEMonthNameParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/de/DEMonthNameParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "util",
      "PATTERN",
      "RegExp",
      "MONTH_NAME_GROUP",
      "YEAR_GROUP",
      "YEAR_BE_GROUP",
      "YEAR_GROUP2",
      "YEAR_BE_GROUP2",
      "exports",
      "ENMonthNameParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "result",
      "substr",
      "length",
      "index",
      "month",
      "MONTH_OFFSET",
      "toLowerCase",
      "day",
      "year",
      "parseInt",
      "test",
      "start",
      "imply",
      "assign",
      "refMoment",
      "date",
      "nextYear",
      "clone",
      "add",
      "lastYear",
      "Math",
      "abs",
      "diff",
      "tags"
    ],
    "mappings": "AAAA;;;;;;;;AASA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAP,CAAqBC,MAAlC;;AACA,IAAIC,YAAY,GAAGF,OAAO,CAAC,cAAD,CAAP,CAAwBE,YAA3C;;AACA,IAAIC,IAAI,GAAIH,OAAO,CAAC,gBAAD,CAAnB;;AAEA,IAAII,OAAO,GAAG,IAAIC,MAAJ,CAAW,0BACrB,0MADqB,GAErB,MAFqB,GAGrB,KAHqB,GAIjB,gGAJiB,GAKrB,IALqB,GAMrB,iBANU,EAMS,GANT,CAAd;AAQA,IAAIC,gBAAgB,GAAG,CAAvB;AACA,IAAIC,UAAU,GAAG,CAAjB;AACA,IAAIC,aAAa,GAAG,CAApB;AACA,IAAIC,WAAW,GAAG,CAAlB;AACA,IAAIC,cAAc,GAAG,CAArB;;AAEAC,OAAO,CAACV,MAAR,GAAiB,SAASW,iBAAT,GAA4B;AACzCX,EAAAA,MAAM,CAACY,KAAP,CAAa,IAAb,EAAmBC,SAAnB;;AAEA,OAAKC,OAAL,GAAe,YAAW;AAAE,WAAOX,OAAP;AAAiB,GAA7C;;AAEA,OAAKY,OAAL,GAAe,UAASC,IAAT,EAAeC,GAAf,EAAoBC,KAApB,EAA2BC,GAA3B,EAA+B;AAC1C,QAAIC,MAAM,GAAG,IAAInB,YAAJ,CAAiB;AAC1Be,MAAAA,IAAI,EAAEE,KAAK,CAAC,CAAD,CAAL,CAASG,MAAT,CAAgBH,KAAK,CAAC,CAAD,CAAL,CAASI,MAAzB,EAAiCJ,KAAK,CAAC,CAAD,CAAL,CAASI,MAAT,GAAkBJ,KAAK,CAAC,CAAD,CAAL,CAASI,MAA5D,CADoB;AAE1BC,MAAAA,KAAK,EAAEL,KAAK,CAACK,KAAN,GAAcL,KAAK,CAAC,CAAD,CAAL,CAASI,MAFJ;AAG1BL,MAAAA,GAAG,EAAEA;AAHqB,KAAjB,CAAb;AAOA,QAAIO,KAAK,GAAGN,KAAK,CAACb,gBAAD,CAAjB;AACAmB,IAAAA,KAAK,GAAGtB,IAAI,CAACuB,YAAL,CAAkBD,KAAK,CAACE,WAAN,EAAlB,CAAR;AAEA,QAAIC,GAAG,GAAG,CAAV;AAEA,QAAIC,IAAI,GAAG,IAAX;;AACA,QAAIV,KAAK,CAACZ,UAAD,CAAL,IAAqBY,KAAK,CAACV,WAAD,CAA9B,EAA6C;AACzCoB,MAAAA,IAAI,GAAGV,KAAK,CAACZ,UAAD,CAAL,IAAqBY,KAAK,CAACV,WAAD,CAAjC;AACAoB,MAAAA,IAAI,GAAGC,QAAQ,CAACD,IAAD,CAAf;;AAEA,UAAIV,KAAK,CAACX,aAAD,CAAL,IAAwBW,KAAK,CAACT,cAAD,CAAjC,EAAmD;AAC/C,YAAI,KAAKqB,IAAL,CAAUZ,KAAK,CAACX,aAAD,CAAL,IAAwBW,KAAK,CAACT,cAAD,CAAvC,CAAJ,EAA8D;AAC1D;AACAmB,UAAAA,IAAI,GAAG,CAACA,IAAR;AACH;AAEJ,OAND,MAMO,IAAIA,IAAI,GAAG,GAAX,EAAe;AAElBA,QAAAA,IAAI,GAAGA,IAAI,GAAG,IAAd;AACH;AACJ;;AAED,QAAGA,IAAH,EAAQ;AACJR,MAAAA,MAAM,CAACW,KAAP,CAAaC,KAAb,CAAmB,KAAnB,EAA0BL,GAA1B;AACAP,MAAAA,MAAM,CAACW,KAAP,CAAaE,MAAb,CAAoB,OAApB,EAA6BT,KAA7B;AACAJ,MAAAA,MAAM,CAACW,KAAP,CAAaE,MAAb,CAAoB,MAApB,EAA4BL,IAA5B;AACH,KAJD,MAIO;AAEH;AACA,UAAIM,SAAS,GAAGpC,MAAM,CAACmB,GAAD,CAAtB;AACAiB,MAAAA,SAAS,CAACV,KAAV,CAAgBA,KAAK,GAAG,CAAxB;AACAU,MAAAA,SAAS,CAACC,IAAV,CAAeR,GAAf;AAEA,UAAIS,QAAQ,GAAGF,SAAS,CAACG,KAAV,GAAkBC,GAAlB,CAAsB,CAAtB,EAAyB,GAAzB,CAAf;AACA,UAAIC,QAAQ,GAAGL,SAAS,CAACG,KAAV,GAAkBC,GAAlB,CAAsB,CAAC,CAAvB,EAA0B,GAA1B,CAAf;;AACA,UAAIE,IAAI,CAACC,GAAL,CAASL,QAAQ,CAACM,IAAT,CAAc5C,MAAM,CAACmB,GAAD,CAApB,CAAT,IAAuCuB,IAAI,CAACC,GAAL,CAASP,SAAS,CAACQ,IAAV,CAAe5C,MAAM,CAACmB,GAAD,CAArB,CAAT,CAA3C,EAAkF;AAC9EiB,QAAAA,SAAS,GAAGE,QAAZ;AACH,OAFD,MAGK,IAAII,IAAI,CAACC,GAAL,CAASF,QAAQ,CAACG,IAAT,CAAc5C,MAAM,CAACmB,GAAD,CAApB,CAAT,IAAuCuB,IAAI,CAACC,GAAL,CAASP,SAAS,CAACQ,IAAV,CAAe5C,MAAM,CAACmB,GAAD,CAArB,CAAT,CAA3C,EAAkF;AACnFiB,QAAAA,SAAS,GAAGK,QAAZ;AACH;;AAEDnB,MAAAA,MAAM,CAACW,KAAP,CAAaC,KAAb,CAAmB,KAAnB,EAA0BL,GAA1B;AACAP,MAAAA,MAAM,CAACW,KAAP,CAAaE,MAAb,CAAoB,OAApB,EAA6BT,KAA7B;AACAJ,MAAAA,MAAM,CAACW,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2BE,SAAS,CAACN,IAAV,EAA3B;AACH;;AAEDR,IAAAA,MAAM,CAACuB,IAAP,CAAY,mBAAZ,IAAmC,IAAnC;AACA,WAAOvB,MAAP;AACH,GAzDD;AA0DH,CA/DD",
    "sourcesContent": [
      "/*\n    \n    The parser for parsing month name and year.\n    \n    EX. \n        - Januar\n        - Januar 2012\n*/\n\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\nvar util  = require('../../utils/DE');\n\nvar PATTERN = new RegExp('(^|\\\\D\\\\s+|[^\\\\w\\\\s])' +\n    '(Jan\\\\.?|Januar|Feb\\\\.?|Februar|M채r\\\\.?|M(?:채|ae)rz|Mrz\\\\.?|Apr\\\\.?|April|Mai\\\\.?|Jun\\\\.?|Juni|Jul\\\\.?|Juli|Aug\\\\.?|August|Sep\\\\.?|Sept\\\\.?|September|Okt\\\\.?|Oktober|Nov\\\\.?|November|Dez\\\\.?|Dezember)' + \n    '\\\\s*' +\n    '(?:' +\n        ',?\\\\s*(?:([0-9]{4})(\\\\s*[vn]\\\\.?\\\\s*C(?:hr)?\\\\.?)?|([0-9]{1,4})\\\\s*([vn]\\\\.?\\\\s*C(?:hr)?\\\\.?))' +\n    ')?' +\n    '(?=[^\\\\s\\\\w]|$)', 'i');\n\nvar MONTH_NAME_GROUP = 2;\nvar YEAR_GROUP = 3;\nvar YEAR_BE_GROUP = 4;\nvar YEAR_GROUP2 = 5;\nvar YEAR_BE_GROUP2 = 6;\n\nexports.Parser = function ENMonthNameParser(){\n    Parser.apply(this, arguments);\n\n    this.pattern = function() { return PATTERN; }\n    \n    this.extract = function(text, ref, match, opt){\n        var result = new ParsedResult({\n            text: match[0].substr(match[1].length, match[0].length - match[1].length),\n            index: match.index + match[1].length,\n            ref: ref,\n        });\n\n        \n        var month = match[MONTH_NAME_GROUP];\n        month = util.MONTH_OFFSET[month.toLowerCase()];\n\n        var day = 1;\n\n        var year = null;\n        if (match[YEAR_GROUP] || match[YEAR_GROUP2]) {\n            year = match[YEAR_GROUP] || match[YEAR_GROUP2];\n            year = parseInt(year);\n\n            if (match[YEAR_BE_GROUP] || match[YEAR_BE_GROUP2]) {\n                if (/v/i.test(match[YEAR_BE_GROUP] || match[YEAR_BE_GROUP2])) {\n                    // v.Chr.\n                    year = -year;\n                }\n\n            } else if (year < 100){ \n\n                year = year + 2000;\n            }\n        }\n\n        if(year){\n            result.start.imply('day', day);\n            result.start.assign('month', month);\n            result.start.assign('year', year);\n        } else {\n            \n            //Find the most appropriated year\n            var refMoment = moment(ref);\n            refMoment.month(month - 1);\n            refMoment.date(day);\n\n            var nextYear = refMoment.clone().add(1, 'y');\n            var lastYear = refMoment.clone().add(-1, 'y');\n            if( Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref))) ){  \n                refMoment = nextYear;\n            }\n            else if( Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref))) ){ \n                refMoment = lastYear;\n            }\n\n            result.start.imply('day', day);\n            result.start.assign('month', month);\n            result.start.imply('year', refMoment.year());\n        }\n\n        result.tags['DEMonthNameParser'] = true;\n        return result;\n    }\n}\n\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

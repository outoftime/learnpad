{
  "ast": null,
  "code": "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { parse, tokenize } from 'esprima';\nimport find from 'lodash-es/find';\nimport inRange from 'lodash-es/inRange';\nimport Validator from '../Validator';\nvar UNEXPECTED_TOKEN_EXPR = /^Unexpected token ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)$/;\nvar errorMap = {\n  'Unexpected string': function UnexpectedString(_ref) {\n    var token = _ref.token;\n    return {\n      reason: 'unexpected-string',\n      payload: {\n        value: token.value\n      },\n      suppresses: ['expected-identifier', 'strict-operators.custom-case', 'unused-variable']\n    };\n  },\n  'Unexpected number': function UnexpectedNumber(_ref2) {\n    var token = _ref2.token;\n    return {\n      reason: 'unexpected-number',\n      payload: {\n        value: token.value\n      },\n      suppresses: ['expected-identifier', 'strict-operators.custom-case', 'unused-variable']\n    };\n  },\n  'Unexpected identifier': function UnexpectedIdentifier(_ref3) {\n    var token = _ref3.token;\n    return {\n      reason: 'unexpected-identifier',\n      payload: {\n        name: token.value\n      }\n    };\n  },\n  'Invalid left-hand side in assignment': function InvalidLeftHandSideInAssignment(_ref4) {\n    var token = _ref4.token;\n    var message;\n\n    switch (token.type) {\n      case 'String':\n        message = 'invalid-left-hand-string';\n        break;\n\n      case 'Numeric':\n        message = 'invalid-left-hand-number';\n        break;\n\n      case 'Boolean':\n        message = 'invalid-left-hand-boolean';\n        break;\n\n      default:\n        message = 'invalid-left-hand-value';\n        break;\n    }\n\n    return {\n      reason: \"\".concat(message),\n      payload: {\n        value: token.value\n      },\n      suppresses: ['missing-semicolon', 'expected-identifier', 'unexpected-expression', 'closing-match', 'strict-operators.custom-case']\n    };\n  },\n  'Unexpected end of input': function UnexpectedEndOfInput() {\n    return {\n      reason: 'end-of-input'\n    };\n  },\n  'Unexpected token ILLEGAL': function UnexpectedTokenILLEGAL() {\n    return {\n      reason: 'tokenize-error'\n    };\n  }\n};\n\nfunction findTokenForError(error, tokens) {\n  return find(tokens, function (token) {\n    var _token$range = _slicedToArray(token.range, 2),\n        startLocation = _token$range[0],\n        endLocation = _token$range[1];\n\n    return inRange(error.index, startLocation, endLocation + 1);\n  });\n}\n\nvar EsprimaValidator =\n/*#__PURE__*/\nfunction (_Validator) {\n  _inherits(EsprimaValidator, _Validator);\n\n  function EsprimaValidator(source) {\n    _classCallCheck(this, EsprimaValidator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(EsprimaValidator).call(this, source, 'javascript', errorMap));\n  }\n\n  _createClass(EsprimaValidator, [{\n    key: \"getRawErrors\",\n    value: function () {\n      var _getRawErrors = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var tokens, token;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                parse(this.source);\n                _context.next = 15;\n                break;\n\n              case 4:\n                _context.prev = 4;\n                _context.t0 = _context[\"catch\"](0);\n                _context.prev = 6;\n                tokens = tokenize(this.source, {\n                  range: true,\n                  comment: true\n                });\n                token = findTokenForError(_context.t0, tokens);\n                return _context.abrupt(\"return\", [{\n                  error: _context.t0,\n                  token: token\n                }]);\n\n              case 12:\n                _context.prev = 12;\n                _context.t1 = _context[\"catch\"](6);\n                return _context.abrupt(\"return\", [{\n                  error: _context.t1\n                }]);\n\n              case 15:\n                return _context.abrupt(\"return\", []);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 4], [6, 12]]);\n      }));\n\n      function getRawErrors() {\n        return _getRawErrors.apply(this, arguments);\n      }\n\n      return getRawErrors;\n    }()\n  }, {\n    key: \"keyForError\",\n    value: function keyForError(error) {\n      return error.error.description;\n    }\n  }, {\n    key: \"mapError\",\n    value: function mapError(error) {\n      var mappedError = _get(_getPrototypeOf(EsprimaValidator.prototype), \"mapError\", this).call(this, error);\n\n      if (mappedError) {\n        return mappedError;\n      }\n\n      var match = UNEXPECTED_TOKEN_EXPR.exec(this.keyForError(error));\n\n      if (match) {\n        return {\n          reason: 'unexpected-token',\n          payload: {\n            token: match[1]\n          },\n          suppresses: ['unexpected-expression']\n        };\n      }\n\n      return {\n        reason: 'tokenize-error'\n      };\n    }\n  }, {\n    key: \"locationForError\",\n    value: function locationForError(error) {\n      var row = error.error.lineNumber - 1;\n      var column = error.error.column - 1;\n      return {\n        row: row,\n        column: column\n      };\n    }\n  }]);\n\n  return EsprimaValidator;\n}(Validator);\n\nexport default (function (source) {\n  return new EsprimaValidator(source).getAnnotations();\n});",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/src/validations/javascript/esprima.js"
    ],
    "names": [
      "parse",
      "tokenize",
      "find",
      "inRange",
      "Validator",
      "UNEXPECTED_TOKEN_EXPR",
      "errorMap",
      "token",
      "reason",
      "payload",
      "value",
      "suppresses",
      "name",
      "message",
      "type",
      "findTokenForError",
      "error",
      "tokens",
      "range",
      "startLocation",
      "endLocation",
      "index",
      "EsprimaValidator",
      "source",
      "comment",
      "description",
      "mappedError",
      "match",
      "exec",
      "keyForError",
      "row",
      "lineNumber",
      "column",
      "getAnnotations"
    ],
    "mappings": "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",
    "sourcesContent": [
      "import {parse, tokenize} from 'esprima';\nimport find from 'lodash-es/find';\nimport inRange from 'lodash-es/inRange';\n\nimport Validator from '../Validator';\n\nconst UNEXPECTED_TOKEN_EXPR = /^Unexpected token (.+)$/u;\n\nconst errorMap = {\n  'Unexpected string': ({token}) => ({\n    reason: 'unexpected-string',\n    payload: {value: token.value},\n    suppresses: [\n      'expected-identifier',\n      'strict-operators.custom-case',\n      'unused-variable',\n    ],\n  }),\n\n  'Unexpected number': ({token}) => ({\n    reason: 'unexpected-number',\n    payload: {value: token.value},\n    suppresses: [\n      'expected-identifier',\n      'strict-operators.custom-case',\n      'unused-variable',\n    ],\n  }),\n\n  'Unexpected identifier': ({token}) => ({\n    reason: 'unexpected-identifier',\n    payload: {name: token.value},\n  }),\n\n  'Invalid left-hand side in assignment': ({token}) => {\n    let message;\n    switch (token.type) {\n      case 'String':\n        message = 'invalid-left-hand-string';\n        break;\n      case 'Numeric':\n        message = 'invalid-left-hand-number';\n        break;\n      case 'Boolean':\n        message = 'invalid-left-hand-boolean';\n        break;\n      default:\n        message = 'invalid-left-hand-value';\n        break;\n    }\n\n    return {\n      reason: `${message}`,\n      payload: {value: token.value},\n      suppresses: [\n        'missing-semicolon',\n        'expected-identifier',\n        'unexpected-expression',\n        'closing-match',\n        'strict-operators.custom-case',\n      ],\n    };\n  },\n\n  'Unexpected end of input': () => ({reason: 'end-of-input'}),\n\n  'Unexpected token ILLEGAL': () => ({reason: 'tokenize-error'}),\n};\n\nfunction findTokenForError(error, tokens) {\n  return find(tokens, token => {\n    const [startLocation, endLocation] = token.range;\n    return inRange(error.index, startLocation, endLocation + 1);\n  });\n}\n\nclass EsprimaValidator extends Validator {\n  constructor(source) {\n    super(source, 'javascript', errorMap);\n  }\n\n  async getRawErrors() {\n    try {\n      parse(this.source);\n    } catch (error) {\n      try {\n        const tokens = tokenize(this.source, {range: true, comment: true});\n        const token = findTokenForError(error, tokens);\n        return [{error, token}];\n      } catch (tokenizeError) {\n        return [{error: tokenizeError}];\n      }\n    }\n    return [];\n  }\n\n  keyForError(error) {\n    return error.error.description;\n  }\n\n  mapError(error) {\n    const mappedError = super.mapError(error);\n    if (mappedError) {\n      return mappedError;\n    }\n\n    const match = UNEXPECTED_TOKEN_EXPR.exec(this.keyForError(error));\n    if (match) {\n      return {\n        reason: 'unexpected-token',\n        payload: {token: match[1]},\n        suppresses: ['unexpected-expression'],\n      };\n    }\n\n    return {reason: 'tokenize-error'};\n  }\n\n  locationForError(error) {\n    const row = error.error.lineNumber - 1;\n    const column = error.error.column - 1;\n    return {row, column};\n  }\n}\n\nexport default source => new EsprimaValidator(source).getAnnotations();\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

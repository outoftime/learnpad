{
  "ast": null,
  "code": "function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport loadjs from 'loadjs';\nimport once from 'lodash-es/once';\nimport promiseRetry from 'promise-retry';\nimport config from '../config';\nimport ExtendableError from '../util/ExtendableError';\nexport var SCOPES = ['https://www.googleapis.com/auth/classroom.courses.readonly', 'https://www.googleapis.com/auth/classroom.coursework.students', 'https://www.googleapis.com/auth/classroom.coursework.me'];\nvar DISCOVERY_DOCS = ['https://classroom.googleapis.com/$discovery/rest?version=v1'];\n\nvar LoadError =\n/*#__PURE__*/\nfunction (_ExtendableError) {\n  _inherits(LoadError, _ExtendableError);\n\n  function LoadError() {\n    _classCallCheck(this, LoadError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LoadError).apply(this, arguments));\n  }\n\n  return LoadError;\n}(ExtendableError);\n\nvar isGapiLoadedAndConfigured = false;\nvar loadGapi = once(function () {\n  return promiseRetry(\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(retry) {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return new Promise(function (resolve, reject) {\n                loadjs('https://apis.google.com/js/client.js', {\n                  success: function success() {\n                    resolve(window.gapi);\n                  },\n                  error: function error(failedPaths) {\n                    reject(new LoadError(\"Failed to load \".concat(failedPaths.join(', '))));\n                  }\n                });\n              });\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](0);\n              return _context.abrupt(\"return\", retry(_context.t0));\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 6]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {\n    retries: 16,\n    factor: 2,\n    minTimeout: 200,\n    maxTimeout: 4000\n  });\n});\nexport var loadAndConfigureGapi = once(\n/*#__PURE__*/\n_asyncToGenerator(\n/*#__PURE__*/\nregeneratorRuntime.mark(function _callee2() {\n  var gapi;\n  return regeneratorRuntime.wrap(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return loadGapi();\n\n        case 2:\n          gapi = _context2.sent;\n          _context2.next = 5;\n          return new Promise(function (resolve, reject) {\n            gapi.load('client:auth2', {\n              callback: function callback() {\n                resolve(gapi);\n              },\n              onerror: reject,\n              timeout: 5000,\n              ontimeout: function ontimeout() {\n                reject(new Error('Timed out'));\n              }\n            });\n          });\n\n        case 5:\n          _context2.next = 7;\n          return gapi.client.init({\n            apiKey: config.firebaseApiKey,\n            clientId: config.firebaseClientId,\n            discoveryDocs: DISCOVERY_DOCS,\n            scope: SCOPES.join(' ')\n          });\n\n        case 7:\n          isGapiLoadedAndConfigured = true;\n          return _context2.abrupt(\"return\", gapi);\n\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _callee2);\n})));\nexport function getGapiSync() {\n  if (!isGapiLoadedAndConfigured) {\n    throw new Error('Attempted to synchronously access `gapi` before it was loaded');\n  }\n\n  return window.gapi;\n}",
  "map": {
    "version": 3,
    "sources": ["/Users/peter/Desktop/code/popcode/src/services/gapi.js"],
    "names": [
      "loadjs",
      "once",
      "promiseRetry",
      "config",
      "ExtendableError",
      "SCOPES",
      "DISCOVERY_DOCS",
      "LoadError",
      "isGapiLoadedAndConfigured",
      "loadGapi",
      "retry",
      "Promise",
      "resolve",
      "reject",
      "success",
      "window",
      "gapi",
      "error",
      "failedPaths",
      "join",
      "retries",
      "factor",
      "minTimeout",
      "maxTimeout",
      "loadAndConfigureGapi",
      "load",
      "callback",
      "onerror",
      "timeout",
      "ontimeout",
      "Error",
      "client",
      "init",
      "apiKey",
      "firebaseApiKey",
      "clientId",
      "firebaseClientId",
      "discoveryDocs",
      "scope",
      "getGapiSync"
    ],
    "mappings": "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",
    "sourcesContent": [
      "import loadjs from 'loadjs';\nimport once from 'lodash-es/once';\nimport promiseRetry from 'promise-retry';\n\nimport config from '../config';\nimport ExtendableError from '../util/ExtendableError';\n\nexport const SCOPES = [\n  'https://www.googleapis.com/auth/classroom.courses.readonly',\n  'https://www.googleapis.com/auth/classroom.coursework.students',\n  'https://www.googleapis.com/auth/classroom.coursework.me',\n];\n\nconst DISCOVERY_DOCS = [\n  'https://classroom.googleapis.com/$discovery/rest?version=v1',\n];\n\nclass LoadError extends ExtendableError {}\n\nlet isGapiLoadedAndConfigured = false;\n\nconst loadGapi = once(() =>\n  promiseRetry(\n    async retry => {\n      try {\n        return await new Promise((resolve, reject) => {\n          loadjs('https://apis.google.com/js/client.js', {\n            success() {\n              resolve(window.gapi);\n            },\n            error(failedPaths) {\n              reject(new LoadError(`Failed to load ${failedPaths.join(', ')}`));\n            },\n          });\n        });\n      } catch (e) {\n        return retry(e);\n      }\n    },\n    {\n      retries: 16,\n      factor: 2,\n      minTimeout: 200,\n      maxTimeout: 4000,\n    },\n  ),\n);\n\nexport const loadAndConfigureGapi = once(async () => {\n  const gapi = await loadGapi();\n  await new Promise((resolve, reject) => {\n    gapi.load('client:auth2', {\n      callback: () => {\n        resolve(gapi);\n      },\n      onerror: reject,\n      timeout: 5000,\n      ontimeout: () => {\n        reject(new Error('Timed out'));\n      },\n    });\n  });\n  await gapi.client.init({\n    apiKey: config.firebaseApiKey,\n    clientId: config.firebaseClientId,\n    discoveryDocs: DISCOVERY_DOCS,\n    scope: SCOPES.join(' '),\n  });\n\n  isGapiLoadedAndConfigured = true;\n\n  return gapi;\n});\n\nexport function getGapiSync() {\n  if (!isGapiLoadedAndConfigured) {\n    throw new Error(\n      'Attempted to synchronously access `gapi` before it was loaded',\n    );\n  }\n\n  return window.gapi;\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

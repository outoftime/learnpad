{
  "ast": null,
  "code": "function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// This rule checks for any unexpected tags or text that\n// don't get caught by other validators, specifically:\n//\n// * Any tags or text outside the <html> element\n// * Any text that is inside the <html> element but not part\n//   of the <head> or <body> tags\nimport findLastIndex from 'lodash-es/findLastIndex';\nimport Code from './Code';\n\nvar NodeOutsideBody =\n/*#__PURE__*/\nfunction () {\n  function NodeOutsideBody() {\n    _classCallCheck(this, NodeOutsideBody);\n\n    this._openTagStack = [];\n    this._invalidTextLocations = [];\n    this._invalidTagLocations = [];\n  }\n\n  _createClass(NodeOutsideBody, [{\n    key: \"openTag\",\n    value: function openTag(location, _ref) {\n      var name = _ref.name;\n\n      if (this._isTopLevel() && name !== 'html' || this._isInsideHtmlTag() && name !== 'head' && name !== 'body') {\n        this._invalidTagLocations.push({\n          location: location,\n          tagName: name\n        });\n      }\n\n      this._openTagStack.push({\n        location: location,\n        name: name\n      });\n    }\n  }, {\n    key: \"closeTag\",\n    value: function closeTag(location, name) {\n      var openIndex = findLastIndex(this._openTagStack, function (openTag) {\n        return openTag.name === name;\n      });\n      var isOpened = openIndex >= 0;\n\n      if (isOpened) {\n        this._openTagStack.splice(openIndex);\n      }\n    }\n  }, {\n    key: \"text\",\n    value: function text(location, _text) {\n      var trimmedText = _text.trim();\n\n      if (trimmedText && (this._isTopLevel() || this._isInsideHtmlTag() || this._isDirectChildOfHead())) {\n        var matchingWhitespaces = _text.match(/^([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+)/g);\n\n        if (matchingWhitespaces) {\n          var whitespaces = matchingWhitespaces[0].split('\\n');\n          var blankLines = whitespaces.length - 1;\n          var columnOffset = whitespaces[blankLines].length;\n\n          this._invalidTextLocations.push({\n            location: {\n              row: location.row + blankLines,\n              column: columnOffset\n            }\n          });\n        } else {\n          this._invalidTextLocations.push({\n            location: location\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_isTopLevel\",\n    value: function _isTopLevel() {\n      return this._openTagStack.length === 0;\n    }\n  }, {\n    key: \"_isInsideHtmlTag\",\n    value: function _isInsideHtmlTag() {\n      return this._openTagStack.length === 1 && this._openTagStack[0].name === 'html';\n    }\n  }, {\n    key: \"_isDirectChildOfHead\",\n    value: function _isDirectChildOfHead() {\n      return this._openTagStack.length === 2 && this._openTagStack[0].name === 'html' && this._openTagStack[1].name === 'head';\n    }\n  }, {\n    key: \"done\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function done() {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, location, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, tagName;\n\n      return regeneratorRuntime.wrap(function done$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 3;\n              _iterator = this._invalidTextLocations[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 12;\n                break;\n              }\n\n              location = _step.value.location;\n              _context.next = 9;\n              return {\n                code: Code.INVALID_TEXT_OUTSIDE_BODY,\n                location: location\n              };\n\n            case 9:\n              _iteratorNormalCompletion = true;\n              _context.next = 5;\n              break;\n\n            case 12:\n              _context.next = 18;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t0 = _context[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 18:\n              _context.prev = 18;\n              _context.prev = 19;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 21:\n              _context.prev = 21;\n\n              if (!_didIteratorError) {\n                _context.next = 24;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 24:\n              return _context.finish(21);\n\n            case 25:\n              return _context.finish(18);\n\n            case 26:\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 29;\n              _iterator2 = this._invalidTagLocations[Symbol.iterator]();\n\n            case 31:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 38;\n                break;\n              }\n\n              _step2$value = _step2.value, location = _step2$value.location, tagName = _step2$value.tagName;\n              _context.next = 35;\n              return {\n                code: Code.INVALID_TAG_OUTSIDE_BODY,\n                tagName: tagName,\n                location: location\n              };\n\n            case 35:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 31;\n              break;\n\n            case 38:\n              _context.next = 44;\n              break;\n\n            case 40:\n              _context.prev = 40;\n              _context.t1 = _context[\"catch\"](29);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t1;\n\n            case 44:\n              _context.prev = 44;\n              _context.prev = 45;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 47:\n              _context.prev = 47;\n\n              if (!_didIteratorError2) {\n                _context.next = 50;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 50:\n              return _context.finish(47);\n\n            case 51:\n              return _context.finish(44);\n\n            case 52:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, done, this, [[3, 14, 18, 26], [19,, 21, 25], [29, 40, 44, 52], [45,, 47, 51]]);\n    })\n  }]);\n\n  return NodeOutsideBody;\n}();\n\nexport { NodeOutsideBody as default };",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/src/validations/html/rules/NodeOutsideBody.js"
    ],
    "names": [
      "findLastIndex",
      "Code",
      "NodeOutsideBody",
      "_openTagStack",
      "_invalidTextLocations",
      "_invalidTagLocations",
      "location",
      "name",
      "_isTopLevel",
      "_isInsideHtmlTag",
      "push",
      "tagName",
      "openIndex",
      "openTag",
      "isOpened",
      "splice",
      "text",
      "trimmedText",
      "trim",
      "_isDirectChildOfHead",
      "matchingWhitespaces",
      "match",
      "whitespaces",
      "split",
      "blankLines",
      "length",
      "columnOffset",
      "row",
      "column",
      "code",
      "INVALID_TEXT_OUTSIDE_BODY",
      "INVALID_TAG_OUTSIDE_BODY"
    ],
    "mappings": "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",
    "sourcesContent": [
      "// This rule checks for any unexpected tags or text that\n// don't get caught by other validators, specifically:\n//\n// * Any tags or text outside the <html> element\n// * Any text that is inside the <html> element but not part\n//   of the <head> or <body> tags\n\nimport findLastIndex from 'lodash-es/findLastIndex';\n\nimport Code from './Code';\n\nexport default class NodeOutsideBody {\n  constructor() {\n    this._openTagStack = [];\n    this._invalidTextLocations = [];\n    this._invalidTagLocations = [];\n  }\n\n  openTag(location, {name}) {\n    if (\n      (this._isTopLevel() && name !== 'html') ||\n      (this._isInsideHtmlTag() && name !== 'head' && name !== 'body')\n    ) {\n      this._invalidTagLocations.push({\n        location,\n        tagName: name,\n      });\n    }\n\n    this._openTagStack.push({location, name});\n  }\n\n  closeTag(location, name) {\n    const openIndex = findLastIndex(\n      this._openTagStack,\n      openTag => openTag.name === name,\n    );\n\n    const isOpened = openIndex >= 0;\n    if (isOpened) {\n      this._openTagStack.splice(openIndex);\n    }\n  }\n\n  text(location, text) {\n    const trimmedText = text.trim();\n    if (\n      trimmedText &&\n      (this._isTopLevel() ||\n        this._isInsideHtmlTag() ||\n        this._isDirectChildOfHead())\n    ) {\n      const matchingWhitespaces = text.match(/^(\\s+)/gu);\n\n      if (matchingWhitespaces) {\n        const whitespaces = matchingWhitespaces[0].split('\\n');\n        const blankLines = whitespaces.length - 1;\n        const columnOffset = whitespaces[blankLines].length;\n        this._invalidTextLocations.push({\n          location: {\n            row: location.row + blankLines,\n            column: columnOffset,\n          },\n        });\n      } else {\n        this._invalidTextLocations.push({location});\n      }\n    }\n  }\n\n  _isTopLevel() {\n    return this._openTagStack.length === 0;\n  }\n\n  _isInsideHtmlTag() {\n    return (\n      this._openTagStack.length === 1 && this._openTagStack[0].name === 'html'\n    );\n  }\n\n  _isDirectChildOfHead() {\n    return (\n      this._openTagStack.length === 2 &&\n      this._openTagStack[0].name === 'html' &&\n      this._openTagStack[1].name === 'head'\n    );\n  }\n\n  *done() {\n    for (const {location} of this._invalidTextLocations) {\n      yield {\n        code: Code.INVALID_TEXT_OUTSIDE_BODY,\n        location,\n      };\n    }\n    for (const {location, tagName} of this._invalidTagLocations) {\n      yield {\n        code: Code.INVALID_TAG_OUTSIDE_BODY,\n        tagName,\n        location,\n      };\n    }\n  }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

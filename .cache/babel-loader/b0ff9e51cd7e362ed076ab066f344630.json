{
  "ast": null,
  "code": "function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { t } from 'i18next';\nimport assign from 'lodash-es/assign';\nimport map from 'lodash-es/map';\nimport compact from 'lodash-es/compact';\nimport remark from 'remark';\nimport stripMarkdown from 'strip-markdown';\nimport config from '../config';\n\nvar Validator =\n/*#__PURE__*/\nfunction () {\n  function Validator(source, language, errorMap) {\n    _classCallCheck(this, Validator);\n\n    this.source = source;\n    this._language = language;\n    this._errorMap = errorMap;\n  }\n\n  _createClass(Validator, [{\n    key: \"getAnnotations\",\n    value: function () {\n      var _getAnnotations = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var errors;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.getRawErrors();\n\n              case 2:\n                errors = _context.sent;\n                return _context.abrupt(\"return\", compact(map(errors, this._convertErrorToAnnotation.bind(this))));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAnnotations() {\n        return _getAnnotations.apply(this, arguments);\n      }\n\n      return getAnnotations;\n    }()\n  }, {\n    key: \"mapError\",\n    value: function mapError(rawError) {\n      var key = this.keyForError(rawError);\n\n      if (this._errorMap.hasOwnProperty(key)) {\n        return this._errorMap[key](rawError, this.source);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_convertErrorToAnnotation\",\n    value: function _convertErrorToAnnotation(rawError) {\n      var error = this.mapError(rawError);\n\n      if (!error) {\n        if (config.warnOnDroppedErrors) {\n          // eslint-disable-next-line no-console\n          console.warn(this.constructor.name, 'dropped error', rawError);\n        }\n\n        return null;\n      }\n\n      var message = t(\"errors.\".concat(this._language, \".\").concat(error.reason), error.payload);\n      var location = this.locationForError(rawError);\n      return assign({}, location, error, {\n        text: remark().use(stripMarkdown).processSync(message).toString(),\n        raw: message,\n        type: 'error'\n      });\n    }\n  }, {\n    key: \"keyForError\",\n    value: function keyForError() {\n      throw new Error('Subclasses must define keyForError()');\n    }\n  }, {\n    key: \"getRawErrors\",\n    value: function getRawErrors() {\n      throw new Error('Subclasses must define getRawErrors()');\n    }\n  }, {\n    key: \"rowForError\",\n    value: function rowForError() {\n      throw new Error('Subclasses must define rowForError()');\n    }\n  }, {\n    key: \"columnForError\",\n    value: function columnForError() {\n      throw new Error('Subclasses must define columnForError()');\n    }\n  }]);\n\n  return Validator;\n}();\n\nexport default Validator;",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/src/validations/Validator.js"
    ],
    "names": [
      "t",
      "assign",
      "map",
      "compact",
      "remark",
      "stripMarkdown",
      "config",
      "Validator",
      "source",
      "language",
      "errorMap",
      "_language",
      "_errorMap",
      "getRawErrors",
      "errors",
      "_convertErrorToAnnotation",
      "bind",
      "rawError",
      "key",
      "keyForError",
      "hasOwnProperty",
      "error",
      "mapError",
      "warnOnDroppedErrors",
      "console",
      "warn",
      "constructor",
      "name",
      "message",
      "reason",
      "payload",
      "location",
      "locationForError",
      "text",
      "use",
      "processSync",
      "toString",
      "raw",
      "type",
      "Error"
    ],
    "mappings": ";;;;;;;;;;AAAA,SAAQA,CAAR,QAAgB,SAAhB;AACA,OAAOC,MAAP,MAAmB,kBAAnB;AACA,OAAOC,GAAP,MAAgB,eAAhB;AACA,OAAOC,OAAP,MAAoB,mBAApB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,OAAOC,aAAP,MAA0B,gBAA1B;AAEA,OAAOC,MAAP,MAAmB,WAAnB;;IAEMC,S;;;AACJ,qBAAYC,MAAZ,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;AAAA;;AACtC,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKG,SAAL,GAAiBF,QAAjB;AACA,SAAKG,SAAL,GAAiBF,QAAjB;AACD;;;;;;;;;;;;;;uBAGsB,KAAKG,YAAL,E;;;AAAfC,gBAAAA,M;iDACCX,OAAO,CAACD,GAAG,CAACY,MAAD,EAAS,KAAKC,yBAAL,CAA+BC,IAA/B,CAAoC,IAApC,CAAT,CAAJ,C;;;;;;;;;;;;;;;;;;6BAGPC,Q,EAAU;AACjB,UAAMC,GAAG,GAAG,KAAKC,WAAL,CAAiBF,QAAjB,CAAZ;;AACA,UAAI,KAAKL,SAAL,CAAeQ,cAAf,CAA8BF,GAA9B,CAAJ,EAAwC;AACtC,eAAO,KAAKN,SAAL,CAAeM,GAAf,EAAoBD,QAApB,EAA8B,KAAKT,MAAnC,CAAP;AACD;;AACD,aAAO,IAAP;AACD;;;8CAEyBS,Q,EAAU;AAClC,UAAMI,KAAK,GAAG,KAAKC,QAAL,CAAcL,QAAd,CAAd;;AACA,UAAI,CAACI,KAAL,EAAY;AACV,YAAIf,MAAM,CAACiB,mBAAX,EAAgC;AAC9B;AACAC,UAAAA,OAAO,CAACC,IAAR,CAAa,KAAKC,WAAL,CAAiBC,IAA9B,EAAoC,eAApC,EAAqDV,QAArD;AACD;;AAED,eAAO,IAAP;AACD;;AAED,UAAMW,OAAO,GAAG5B,CAAC,kBACL,KAAKW,SADA,cACaU,KAAK,CAACQ,MADnB,GAEfR,KAAK,CAACS,OAFS,CAAjB;AAKA,UAAMC,QAAQ,GAAG,KAAKC,gBAAL,CAAsBf,QAAtB,CAAjB;AAEA,aAAOhB,MAAM,CAAC,EAAD,EAAK8B,QAAL,EAAeV,KAAf,EAAsB;AACjCY,QAAAA,IAAI,EAAE7B,MAAM,GACT8B,GADG,CACC7B,aADD,EAEH8B,WAFG,CAESP,OAFT,EAGHQ,QAHG,EAD2B;AAKjCC,QAAAA,GAAG,EAAET,OAL4B;AAMjCU,QAAAA,IAAI,EAAE;AAN2B,OAAtB,CAAb;AAQD;;;kCAEa;AACZ,YAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;;;mCAEc;AACb,YAAM,IAAIA,KAAJ,CAAU,uCAAV,CAAN;AACD;;;kCAEa;AACZ,YAAM,IAAIA,KAAJ,CAAU,sCAAV,CAAN;AACD;;;qCAEgB;AACf,YAAM,IAAIA,KAAJ,CAAU,yCAAV,CAAN;AACD;;;;;;AAGH,eAAehC,SAAf",
    "sourcesContent": [
      "import {t} from 'i18next';\nimport assign from 'lodash-es/assign';\nimport map from 'lodash-es/map';\nimport compact from 'lodash-es/compact';\nimport remark from 'remark';\nimport stripMarkdown from 'strip-markdown';\n\nimport config from '../config';\n\nclass Validator {\n  constructor(source, language, errorMap) {\n    this.source = source;\n    this._language = language;\n    this._errorMap = errorMap;\n  }\n\n  async getAnnotations() {\n    const errors = await this.getRawErrors();\n    return compact(map(errors, this._convertErrorToAnnotation.bind(this)));\n  }\n\n  mapError(rawError) {\n    const key = this.keyForError(rawError);\n    if (this._errorMap.hasOwnProperty(key)) {\n      return this._errorMap[key](rawError, this.source);\n    }\n    return null;\n  }\n\n  _convertErrorToAnnotation(rawError) {\n    const error = this.mapError(rawError);\n    if (!error) {\n      if (config.warnOnDroppedErrors) {\n        // eslint-disable-next-line no-console\n        console.warn(this.constructor.name, 'dropped error', rawError);\n      }\n\n      return null;\n    }\n\n    const message = t(\n      `errors.${this._language}.${error.reason}`,\n      error.payload,\n    );\n\n    const location = this.locationForError(rawError);\n\n    return assign({}, location, error, {\n      text: remark()\n        .use(stripMarkdown)\n        .processSync(message)\n        .toString(),\n      raw: message,\n      type: 'error',\n    });\n  }\n\n  keyForError() {\n    throw new Error('Subclasses must define keyForError()');\n  }\n\n  getRawErrors() {\n    throw new Error('Subclasses must define getRawErrors()');\n  }\n\n  rowForError() {\n    throw new Error('Subclasses must define rowForError()');\n  }\n\n  columnForError() {\n    throw new Error('Subclasses must define columnForError()');\n  }\n}\n\nexport default Validator;\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

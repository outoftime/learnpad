{
  "ast": null,
  "code": "/*\n    Date format with slash \"/\" (also \"-\" and \".\") between numbers\n    - Tuesday 11/3/2015 \n    - 11/3/2015\n    - 11/3\n\n    By default the paser us \"middle-endien\" format (US English),\n    then fallback to little-endian if failed.\n    - 11/3/2015 = November 3rd, 2015\n    - 23/4/2015 = April 23th, 2015\n\n    If \"littleEndian\" config is set, the parser will try the little-endian first. \n    - 11/3/2015 = March 11th, 2015\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = new RegExp('(\\\\W|^)' + '(?:' + '(?:on\\\\s*?)?' + '((?:sun|mon|tues?|wed(?:nes)?|thu(?:rs?)?|fri|sat(?:ur)?)(?:day)?)' + '\\\\s*\\\\,?\\\\s*' + ')?' + '([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})' + '(?:' + '[\\\\/\\\\.\\\\-]' + '([0-9]{4}\\s*\\,?\\s*|[0-9]{2}\\s*\\,?\\s*)' + ')?' + '(\\\\W|$)', 'i');\nvar DAYS_OFFSET = {\n  'sunday': 0,\n  'sun': 0,\n  'monday': 1,\n  'mon': 1,\n  'tuesday': 2,\n  'wednesday': 3,\n  'wed': 3,\n  'thursday': 4,\n  'thur': 4,\n  'friday': 5,\n  'fri': 5,\n  'saturday': 6,\n  'sat': 6\n};\nvar OPENNING_GROUP = 1;\nvar ENDING_GROUP = 6;\nvar WEEKDAY_GROUP = 2;\nvar FIRST_NUMBERS_GROUP = 3;\nvar SECOND_NUMBERS_GROUP = 4;\nvar YEAR_GROUP = 5;\n\nexports.Parser = function ENSlashDateFormatParser(config) {\n  Parser.apply(this, arguments);\n  config = config || {};\n  var littleEndian = config.littleEndian;\n  var MONTH_GROUP = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n  var DAY_GROUP = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    if (match[OPENNING_GROUP] == '/' || match[ENDING_GROUP] == '/') {\n      // Long skip, if there is some overlapping like:\n      // XX[/YY/ZZ]\n      // [XX/YY/]ZZ\n      match.index += match[0].length;\n      return;\n    }\n\n    var index = match.index + match[OPENNING_GROUP].length;\n    var text = match[0].substr(match[OPENNING_GROUP].length, match[0].length - match[ENDING_GROUP].length);\n    var result = new ParsedResult({\n      text: text,\n      index: index,\n      ref: ref\n    });\n    if (text.match(/^\\d\\.\\d$/)) return;\n    if (text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}$/)) return; // MM/dd -> OK\n    // MM.dd -> NG\n\n    if (!match[YEAR_GROUP] && match[0].indexOf('/') < 0) return;\n    var date = null;\n    var year = match[YEAR_GROUP] || moment(ref).year() + '';\n    var month = match[MONTH_GROUP];\n    var day = match[DAY_GROUP];\n    month = parseInt(month);\n    day = parseInt(day);\n    year = parseInt(year);\n\n    if (month < 1 || month > 12) {\n      if (month > 12) {\n        // dd/mm/yyyy date format if day looks like a month, and month\n        // looks like a day.\n        if (day >= 1 && day <= 12 && month >= 13 && month <= 31) {\n          // unambiguous\n          var tday = month;\n          month = day;\n          day = tday;\n        } else {\n          // both month and day are <= 12\n          return null;\n        }\n      }\n    }\n\n    if (day < 1 || day > 31) return null;\n\n    if (year < 100) {\n      if (year > 50) {\n        year = year + 1900;\n      } else {\n        year = year + 2000;\n      }\n    }\n\n    result.start.assign('day', day);\n    result.start.assign('month', month);\n\n    if (match[YEAR_GROUP]) {\n      result.start.assign('year', year);\n    } else {\n      result.start.imply('year', year);\n    } //Day of week\n\n\n    if (match[WEEKDAY_GROUP]) {\n      result.start.assign('weekday', DAYS_OFFSET[match[WEEKDAY_GROUP].toLowerCase()]);\n    }\n\n    result.tags['ENSlashDateFormatParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/en/ENSlashDateFormatParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "PATTERN",
      "RegExp",
      "DAYS_OFFSET",
      "OPENNING_GROUP",
      "ENDING_GROUP",
      "WEEKDAY_GROUP",
      "FIRST_NUMBERS_GROUP",
      "SECOND_NUMBERS_GROUP",
      "YEAR_GROUP",
      "exports",
      "ENSlashDateFormatParser",
      "config",
      "apply",
      "arguments",
      "littleEndian",
      "MONTH_GROUP",
      "DAY_GROUP",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "index",
      "length",
      "substr",
      "result",
      "indexOf",
      "date",
      "year",
      "month",
      "day",
      "parseInt",
      "tday",
      "start",
      "assign",
      "imply",
      "toLowerCase",
      "tags"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n    Date format with slash \"/\" (also \"-\" and \".\") between numbers\n    - Tuesday 11/3/2015 \n    - 11/3/2015\n    - 11/3\n\n    By default the paser us \"middle-endien\" format (US English),\n    then fallback to little-endian if failed.\n    - 11/3/2015 = November 3rd, 2015\n    - 23/4/2015 = April 23th, 2015\n\n    If \"littleEndian\" config is set, the parser will try the little-endian first. \n    - 11/3/2015 = March 11th, 2015\n*/\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = new RegExp('(\\\\W|^)' +\n    '(?:' +\n        '(?:on\\\\s*?)?' +\n        '((?:sun|mon|tues?|wed(?:nes)?|thu(?:rs?)?|fri|sat(?:ur)?)(?:day)?)' +\n        '\\\\s*\\\\,?\\\\s*' +\n    ')?' +\n    '([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})' +\n    '(?:' +\n        '[\\\\/\\\\.\\\\-]' +\n        '([0-9]{4}\\s*\\,?\\s*|[0-9]{2}\\s*\\,?\\s*)' +\n    ')?' +\n    '(\\\\W|$)', 'i');\n\nvar DAYS_OFFSET = { 'sunday': 0, 'sun': 0, 'monday': 1, 'mon': 1,'tuesday': 2, 'wednesday': 3, 'wed': 3,\n    'thursday': 4, 'thur': 4,'friday': 5, 'fri': 5,'saturday': 6, 'sat': 6,}\n\n\nvar OPENNING_GROUP = 1;\nvar ENDING_GROUP = 6;\n\nvar WEEKDAY_GROUP = 2;\n\n\nvar FIRST_NUMBERS_GROUP = 3;\nvar SECOND_NUMBERS_GROUP = 4;\n\nvar YEAR_GROUP = 5;\n\nexports.Parser = function ENSlashDateFormatParser(config) {\n    Parser.apply(this, arguments);\n    config = config || {};\n    var littleEndian  = config.littleEndian;\n    var MONTH_GROUP = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n    var DAY_GROUP = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n\n    this.pattern = function () { return PATTERN; };\n    this.extract = function(text, ref, match, opt){\n\n        if(match[OPENNING_GROUP] == '/' || match[ENDING_GROUP] == '/') {\n            // Long skip, if there is some overlapping like:\n            // XX[/YY/ZZ]\n            // [XX/YY/]ZZ\n            match.index += match[0].length\n            return;\n        }\n\n        var index = match.index + match[OPENNING_GROUP].length;\n        var text = match[0].substr(match[OPENNING_GROUP].length, match[0].length - match[ENDING_GROUP].length);\n\n\n        var result = new ParsedResult({\n            text: text,\n            index: index,\n            ref: ref,\n        });\n\n        if(text.match(/^\\d\\.\\d$/)) return;\n        if(text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}$/)) return;\n\n        // MM/dd -> OK\n        // MM.dd -> NG\n        if(!match[YEAR_GROUP] && match[0].indexOf('/') < 0) return;\n\n        var date = null;\n        var year = match[YEAR_GROUP] || moment(ref).year() + '';\n        var month = match[MONTH_GROUP];\n        var day   = match[DAY_GROUP];\n\n        month = parseInt(month);\n        day  = parseInt(day);\n        year = parseInt(year);\n\n        if(month < 1 || month > 12) {\n            if(month > 12) {\n                // dd/mm/yyyy date format if day looks like a month, and month\n                // looks like a day.\n                if (day >= 1 && day <= 12 && month >= 13 && month <= 31) {\n                    // unambiguous\n                    var tday = month;\n                    month = day;\n                    day = tday;\n                }\n                else {\n                    // both month and day are <= 12\n                    return null;\n                }\n            }\n        }\n        if(day < 1 || day > 31) return null;\n\n        if(year < 100){\n            if (year > 50) {\n                year = year + 1900;\n            } else {\n                year = year + 2000;\n            }\n        }\n\n        result.start.assign('day', day);\n        result.start.assign('month', month);\n        if (match[YEAR_GROUP]) {\n            result.start.assign('year', year);\n        } else {\n            result.start.imply('year', year);\n        }\n\n        //Day of week\n        if(match[WEEKDAY_GROUP]) {\n            result.start.assign('weekday', DAYS_OFFSET[match[WEEKDAY_GROUP].toLowerCase()]);\n        }\n\n        result.tags['ENSlashDateFormatParser'] = true;\n        return result;\n    };\n};\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

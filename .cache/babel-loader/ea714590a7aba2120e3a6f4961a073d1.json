{
  "ast": null,
  "code": "function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { connectAdvanced } from 'react-redux';\nimport at from 'lodash-es/at';\nimport findIndex from 'lodash-es/findIndex';\nimport isNull from 'lodash-es/isNull';\nimport map from 'lodash-es/map';\nimport merge from 'lodash-es/merge';\nimport shallowequal from 'shallowequal';\nimport times from 'lodash-es/times';\nimport { createSelector, defaultMemoize } from 'reselect';\nimport { makeGetResizableFlexGrow } from '../../selectors';\nimport { updateResizableFlex } from '../../actions';\nimport calculateFlexGrowAfterDrag from './calculateFlexGrowAfterDrag';\nimport directionAdapterFor from './directionAdapterFor';\nimport isFlexResizingSupported from './isFlexResizingSupported';\nimport shamResizableFlex from './sham';\nvar nextInstanceId = 1;\nexport default function resizableFlex(size) {\n  if (!isFlexResizingSupported()) {\n    return shamResizableFlex(size);\n  }\n\n  var instanceId = (nextInstanceId++).toString();\n  var getResizableFlexGrow = makeGetResizableFlexGrow(instanceId);\n  return connectAdvanced(function (dispatch) {\n    var regions = times(size, function () {\n      return {\n        current: null\n      };\n    });\n    var initialMainSizes = times(size, function () {\n      return null;\n    });\n    var stateIndependentFunctions = {\n      isFlexResizingSupported: true,\n      onResizableFlexDividerDrag: function onResizableFlexDividerDrag(beforeIndex, event, payload) {\n        var afterIndex = findIndex(regions, 'current', beforeIndex + 1);\n\n        var _at = at(regions, [beforeIndex, afterIndex]),\n            _at2 = _slicedToArray(_at, 2),\n            before = _at2[0].current,\n            after = _at2[1].current;\n\n        var _directionAdapterFor = directionAdapterFor(before),\n            getCurrentSize = _directionAdapterFor.getCurrentSize,\n            getDesiredSize = _directionAdapterFor.getDesiredSize;\n\n        var _calculateFlexGrowAft = calculateFlexGrowAfterDrag({\n          currentFlexGrow: Number(getComputedStyle(before)['flex-grow']),\n          currentSize: getCurrentSize(before),\n          desiredSize: getDesiredSize(before, payload),\n          initialMainSize: initialMainSizes[beforeIndex]\n        }, {\n          currentFlexGrow: Number(getComputedStyle(after)['flex-grow']),\n          currentSize: getCurrentSize(after),\n          initialMainSize: initialMainSizes[afterIndex]\n        }),\n            _calculateFlexGrowAft2 = _slicedToArray(_calculateFlexGrowAft, 2),\n            desiredBeforeFlexGrow = _calculateFlexGrowAft2[0],\n            desiredAfterFlexGrow = _calculateFlexGrowAft2[1];\n\n        dispatch(updateResizableFlex(instanceId, [{\n          index: beforeIndex,\n          flexGrow: desiredBeforeFlexGrow\n        }, {\n          index: afterIndex,\n          flexGrow: desiredAfterFlexGrow\n        }]));\n      },\n      resizableFlexRefs: map(regions, function (region, index) {\n        return function (element) {\n          region.current = element;\n\n          if (isNull(element)) {\n            initialMainSizes[index] = null;\n            return;\n          }\n\n          var flexGrowWas = element.style.flexGrow;\n          var flexShrinkWas = element.style.flexShrink;\n          element.style.flexGrow = element.style.flexShrink = '0';\n          initialMainSizes[index] = directionAdapterFor(element).getCurrentSize(element);\n          element.style.flexGrow = flexGrowWas;\n          element.style.flexShrink = flexShrinkWas;\n        };\n      })\n    };\n    return createSelector([getResizableFlexGrow, defaultMemoize(function (_state, ownProps) {\n      return ownProps;\n    }, shallowequal)], function (resizableFlexGrow, ownProps) {\n      return merge({\n        resizableFlexGrow: resizableFlexGrow\n      }, ownProps, stateIndependentFunctions);\n    });\n  }, {\n    getDisplayName: function getDisplayName(componentName) {\n      return \"ResizableFlex(\".concat(componentName, \")\");\n    },\n    methodName: 'resizableFlex'\n  });\n}",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/src/higherOrderComponents/resizableFlex/index.js"
    ],
    "names": [
      "connectAdvanced",
      "at",
      "findIndex",
      "isNull",
      "map",
      "merge",
      "shallowequal",
      "times",
      "createSelector",
      "defaultMemoize",
      "makeGetResizableFlexGrow",
      "updateResizableFlex",
      "calculateFlexGrowAfterDrag",
      "directionAdapterFor",
      "isFlexResizingSupported",
      "shamResizableFlex",
      "nextInstanceId",
      "resizableFlex",
      "size",
      "instanceId",
      "toString",
      "getResizableFlexGrow",
      "dispatch",
      "regions",
      "current",
      "initialMainSizes",
      "stateIndependentFunctions",
      "onResizableFlexDividerDrag",
      "beforeIndex",
      "event",
      "payload",
      "afterIndex",
      "before",
      "after",
      "getCurrentSize",
      "getDesiredSize",
      "currentFlexGrow",
      "Number",
      "getComputedStyle",
      "currentSize",
      "desiredSize",
      "initialMainSize",
      "desiredBeforeFlexGrow",
      "desiredAfterFlexGrow",
      "index",
      "flexGrow",
      "resizableFlexRefs",
      "region",
      "element",
      "flexGrowWas",
      "style",
      "flexShrinkWas",
      "flexShrink",
      "_state",
      "ownProps",
      "resizableFlexGrow",
      "getDisplayName",
      "componentName",
      "methodName"
    ],
    "mappings": "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",
    "sourcesContent": [
      "import {connectAdvanced} from 'react-redux';\nimport at from 'lodash-es/at';\nimport findIndex from 'lodash-es/findIndex';\nimport isNull from 'lodash-es/isNull';\nimport map from 'lodash-es/map';\nimport merge from 'lodash-es/merge';\nimport shallowequal from 'shallowequal';\nimport times from 'lodash-es/times';\nimport {createSelector, defaultMemoize} from 'reselect';\n\nimport {makeGetResizableFlexGrow} from '../../selectors';\nimport {updateResizableFlex} from '../../actions';\n\nimport calculateFlexGrowAfterDrag from './calculateFlexGrowAfterDrag';\nimport directionAdapterFor from './directionAdapterFor';\nimport isFlexResizingSupported from './isFlexResizingSupported';\nimport shamResizableFlex from './sham';\n\nlet nextInstanceId = 1;\n\nexport default function resizableFlex(size) {\n  if (!isFlexResizingSupported()) {\n    return shamResizableFlex(size);\n  }\n\n  const instanceId = (nextInstanceId++).toString();\n  const getResizableFlexGrow = makeGetResizableFlexGrow(instanceId);\n\n  return connectAdvanced(\n    dispatch => {\n      const regions = times(size, () => ({current: null}));\n      const initialMainSizes = times(size, () => null);\n\n      const stateIndependentFunctions = {\n        isFlexResizingSupported: true,\n\n        onResizableFlexDividerDrag(beforeIndex, event, payload) {\n          const afterIndex = findIndex(regions, 'current', beforeIndex + 1);\n          const [{current: before}, {current: after}] = at(regions, [\n            beforeIndex,\n            afterIndex,\n          ]);\n\n          const {getCurrentSize, getDesiredSize} = directionAdapterFor(before);\n\n          const [\n            desiredBeforeFlexGrow,\n            desiredAfterFlexGrow,\n          ] = calculateFlexGrowAfterDrag(\n            {\n              currentFlexGrow: Number(getComputedStyle(before)['flex-grow']),\n              currentSize: getCurrentSize(before),\n              desiredSize: getDesiredSize(before, payload),\n              initialMainSize: initialMainSizes[beforeIndex],\n            },\n            {\n              currentFlexGrow: Number(getComputedStyle(after)['flex-grow']),\n              currentSize: getCurrentSize(after),\n              initialMainSize: initialMainSizes[afterIndex],\n            },\n          );\n\n          dispatch(\n            updateResizableFlex(instanceId, [\n              {index: beforeIndex, flexGrow: desiredBeforeFlexGrow},\n              {index: afterIndex, flexGrow: desiredAfterFlexGrow},\n            ]),\n          );\n        },\n\n        resizableFlexRefs: map(regions, (region, index) => element => {\n          region.current = element;\n          if (isNull(element)) {\n            initialMainSizes[index] = null;\n            return;\n          }\n\n          const flexGrowWas = element.style.flexGrow;\n          const flexShrinkWas = element.style.flexShrink;\n          element.style.flexGrow = element.style.flexShrink = '0';\n          initialMainSizes[index] = directionAdapterFor(element).getCurrentSize(\n            element,\n          );\n          element.style.flexGrow = flexGrowWas;\n          element.style.flexShrink = flexShrinkWas;\n        }),\n      };\n\n      return createSelector(\n        [\n          getResizableFlexGrow,\n          defaultMemoize((_state, ownProps) => ownProps, shallowequal),\n        ],\n        (resizableFlexGrow, ownProps) =>\n          merge({resizableFlexGrow}, ownProps, stateIndependentFunctions),\n      );\n    },\n    {\n      getDisplayName(componentName) {\n        return `ResizableFlex(${componentName})`;\n      },\n      methodName: 'resizableFlex',\n    },\n  );\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

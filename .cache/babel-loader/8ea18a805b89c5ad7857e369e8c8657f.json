{
  "ast": null,
  "code": "/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/DE');\n\nvar PATTERN = new RegExp('' + '(\\\\W|^)vor\\\\s*' + '(' + util.INTEGER_WORDS_PATTERN + '|[0-9]+|einigen|eine[rm]\\\\s*halben|eine[rm])\\\\s*' + '(sekunden?|min(?:ute)?n?|stunden?|wochen?|tag(?:en)?|monat(?:en)?|jahr(?:en)?)\\\\s*' + '(?=(?:\\\\W|$))', 'i');\nvar STRICT_PATTERN = new RegExp('' + '(\\\\W|^)vor\\\\s*' + '([0-9]+|eine(?:r|m))\\\\s*' + '(sekunden?|minuten?|stunden?|tag(?:en)?)' + '(?=(?:\\\\W|$))', 'i');\n\nexports.Parser = function DETimeAgoFormatParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return this.isStrictMode() ? STRICT_PATTERN : PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    if (match.index > 0 && text[match.index - 1].match(/\\w/)) return null;\n    var text = match[0];\n    text = match[0].substr(match[1].length, match[0].length - match[1].length);\n    index = match.index + match[1].length;\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var num = match[2].toLowerCase();\n\n    if (util.INTEGER_WORDS[num] !== undefined) {\n      num = util.INTEGER_WORDS[num];\n    } else if (num === 'einer' || num === 'einem') {\n      num = 1;\n    } else if (num === 'einigen') {\n      num = 3;\n    } else if (/halben/.test(num)) {\n      num = 0.5;\n    } else {\n      num = parseInt(num);\n    }\n\n    var date = moment(ref);\n\n    if (/stunde|min|sekunde/i.test(match[3])) {\n      if (/stunde/i.test(match[3])) {\n        date.add(-num, 'hour');\n      } else if (/min/i.test(match[3])) {\n        date.add(-num, 'minute');\n      } else if (/sekunde/i.test(match[3])) {\n        date.add(-num, 'second');\n      }\n\n      result.start.imply('day', date.date());\n      result.start.imply('month', date.month() + 1);\n      result.start.imply('year', date.year());\n      result.start.assign('hour', date.hour());\n      result.start.assign('minute', date.minute());\n      result.start.assign('second', date.second());\n      result.tags['DETimeAgoFormatParser'] = true;\n      return result;\n    }\n\n    if (/woche/i.test(match[3])) {\n      date.add(-num, 'week');\n      result.start.imply('day', date.date());\n      result.start.imply('month', date.month() + 1);\n      result.start.imply('year', date.year());\n      result.start.imply('weekday', date.day());\n      return result;\n    }\n\n    if (/tag/i.test(match[3])) {\n      date.add(-num, 'd');\n    }\n\n    if (/monat/i.test(match[3])) {\n      date.add(-num, 'month');\n    }\n\n    if (/jahr/i.test(match[3])) {\n      date.add(-num, 'year');\n    }\n\n    result.start.assign('day', date.date());\n    result.start.assign('month', date.month() + 1);\n    result.start.assign('year', date.year());\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/de/DETimeAgoFormatParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "util",
      "PATTERN",
      "RegExp",
      "INTEGER_WORDS_PATTERN",
      "STRICT_PATTERN",
      "exports",
      "DETimeAgoFormatParser",
      "apply",
      "arguments",
      "pattern",
      "isStrictMode",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "index",
      "substr",
      "length",
      "result",
      "num",
      "toLowerCase",
      "INTEGER_WORDS",
      "undefined",
      "test",
      "parseInt",
      "date",
      "add",
      "start",
      "imply",
      "month",
      "year",
      "assign",
      "hour",
      "minute",
      "second",
      "tags",
      "day"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n\n\n*/\n\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\nvar util  = require('../../utils/DE');\n\nvar PATTERN = new RegExp('' +\n    '(\\\\W|^)vor\\\\s*' +\n    '(' + util.INTEGER_WORDS_PATTERN + '|[0-9]+|einigen|eine[rm]\\\\s*halben|eine[rm])\\\\s*' +\n    '(sekunden?|min(?:ute)?n?|stunden?|wochen?|tag(?:en)?|monat(?:en)?|jahr(?:en)?)\\\\s*' +\n    '(?=(?:\\\\W|$))', 'i');\n\nvar STRICT_PATTERN = new RegExp('' +\n    '(\\\\W|^)vor\\\\s*' +\n    '([0-9]+|eine(?:r|m))\\\\s*' +\n    '(sekunden?|minuten?|stunden?|tag(?:en)?)' +\n    '(?=(?:\\\\W|$))', 'i');\n\nexports.Parser = function DETimeAgoFormatParser(){\n    Parser.apply(this, arguments);\n\n    this.pattern = function() {\n        return this.isStrictMode()? STRICT_PATTERN : PATTERN;\n    };\n\n    this.extract = function(text, ref, match, opt){\n\n        if (match.index > 0 && text[match.index-1].match(/\\w/)) return null;\n\n        var text = match[0];\n        text  = match[0].substr(match[1].length, match[0].length - match[1].length);\n        index = match.index + match[1].length;\n\n        var result = new ParsedResult({\n            index: index,\n            text: text,\n            ref: ref\n        });\n\n        var num = match[2].toLowerCase() ;\n        if (util.INTEGER_WORDS[num] !== undefined) {\n            num = util.INTEGER_WORDS[num];\n        } else if (num === 'einer' || num === 'einem') {\n            num = 1;\n        } else if (num === 'einigen') {\n            num = 3;\n        } else if (/halben/.test(num)) {\n            num = 0.5;\n        } else {\n            num = parseInt(num);\n        }\n\n        var date = moment(ref);\n\n        if (/stunde|min|sekunde/i.test(match[3])) {\n            if (/stunde/i.test(match[3])) {\n\n                date.add(-num, 'hour');\n\n            } else if (/min/i.test(match[3])) {\n\n                date.add(-num, 'minute');\n\n            } else if (/sekunde/i.test(match[3])) {\n\n                date.add(-num, 'second');\n            }\n\n            result.start.imply('day', date.date());\n            result.start.imply('month', date.month() + 1);\n            result.start.imply('year', date.year());\n            result.start.assign('hour', date.hour());\n            result.start.assign('minute', date.minute());\n            result.start.assign('second', date.second());\n            result.tags['DETimeAgoFormatParser'] = true;\n            return result;\n        }\n\n        if (/woche/i.test(match[3])) {\n            date.add(-num, 'week');\n\n            result.start.imply('day', date.date());\n            result.start.imply('month', date.month() + 1);\n            result.start.imply('year', date.year());\n            result.start.imply('weekday', date.day());\n            return result;\n        }\n\n        if (/tag/i.test(match[3])) {\n            date.add(-num, 'd');\n        }\n\n        if (/monat/i.test(match[3])) {\n            date.add(-num, 'month');\n        }\n\n        if (/jahr/i.test(match[3])) {\n\n            date.add(-num, 'year');\n        }\n\n        result.start.assign('day', date.date());\n        result.start.assign('month', date.month() + 1);\n        result.start.assign('year', date.year());\n        return result;\n\n    };\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

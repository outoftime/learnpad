{
  "ast": null,
  "code": "/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar DAYS_OFFSET = {\n  'sunday': 0,\n  'sun': 0,\n  'monday': 1,\n  'mon': 1,\n  'tuesday': 2,\n  'tues': 2,\n  'tue': 2,\n  'wednesday': 3,\n  'wed': 3,\n  'thursday': 4,\n  'thurs': 4,\n  'thur': 4,\n  'thu': 4,\n  'friday': 5,\n  'fri': 5,\n  'saturday': 6,\n  'sat': 6\n};\nvar PATTERN = new RegExp('(\\\\W|^)' + '(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?' + '(?:on\\\\s*?)?' + '(?:(this|last|past|next)\\\\s*)?' + '(' + Object.keys(DAYS_OFFSET).join('|') + ')' + '(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?' + '(?:\\\\s*(this|last|past|next)\\\\s*week)?' + '(?=\\\\W|$)', 'i');\nvar PREFIX_GROUP = 2;\nvar WEEKDAY_GROUP = 3;\nvar POSTFIX_GROUP = 4;\n\nexports.updateParsedComponent = function updateParsedComponent(result, ref, offset, modifier) {\n  var startMoment = moment(ref);\n  var startMomentFixed = false;\n  var refOffset = startMoment.day();\n\n  if (modifier == 'last' || modifier == 'past') {\n    startMoment.day(offset - 7);\n    startMomentFixed = true;\n  } else if (modifier == 'next') {\n    startMoment.day(offset + 7);\n    startMomentFixed = true;\n  } else if (modifier == 'this') {\n    startMoment.day(offset);\n  } else {\n    if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {\n      startMoment.day(offset - 7);\n    } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {\n      startMoment.day(offset + 7);\n    } else {\n      startMoment.day(offset);\n    }\n  }\n\n  result.start.assign('weekday', offset);\n\n  if (startMomentFixed) {\n    result.start.assign('day', startMoment.date());\n    result.start.assign('month', startMoment.month() + 1);\n    result.start.assign('year', startMoment.year());\n  } else {\n    result.start.imply('day', startMoment.date());\n    result.start.imply('month', startMoment.month() + 1);\n    result.start.imply('year', startMoment.year());\n  }\n\n  return result;\n};\n\nexports.Parser = function ENWeekdayParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var index = match.index + match[1].length;\n    var text = match[0].substr(match[1].length, match[0].length - match[1].length);\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n    var offset = DAYS_OFFSET[dayOfWeek];\n\n    if (offset === undefined) {\n      return null;\n    }\n\n    var prefix = match[PREFIX_GROUP];\n    var postfix = match[POSTFIX_GROUP];\n    var norm = prefix || postfix;\n    norm = norm || '';\n    norm = norm.toLowerCase();\n    exports.updateParsedComponent(result, ref, offset, norm);\n    result.tags['ENWeekdayParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/en/ENWeekdayParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "DAYS_OFFSET",
      "PATTERN",
      "RegExp",
      "Object",
      "keys",
      "join",
      "PREFIX_GROUP",
      "WEEKDAY_GROUP",
      "POSTFIX_GROUP",
      "exports",
      "updateParsedComponent",
      "result",
      "ref",
      "offset",
      "modifier",
      "startMoment",
      "startMomentFixed",
      "refOffset",
      "day",
      "Math",
      "abs",
      "start",
      "assign",
      "date",
      "month",
      "year",
      "imply",
      "ENWeekdayParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "match",
      "opt",
      "index",
      "length",
      "substr",
      "dayOfWeek",
      "toLowerCase",
      "undefined",
      "prefix",
      "postfix",
      "norm",
      "tags"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n\n\n*/\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar DAYS_OFFSET = { 'sunday': 0, 'sun': 0, 'monday': 1, 'mon': 1,'tuesday': 2, 'tues':2, 'tue':2, 'wednesday': 3, 'wed': 3,\n    'thursday': 4, 'thurs':4, 'thur': 4, 'thu': 4,'friday': 5, 'fri': 5,'saturday': 6, 'sat': 6};\n\nvar PATTERN = new RegExp('(\\\\W|^)' +\n    '(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?' +\n    '(?:on\\\\s*?)?' +\n    '(?:(this|last|past|next)\\\\s*)?' +\n    '(' + Object.keys(DAYS_OFFSET).join('|') + ')' +\n    '(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?' +\n    '(?:\\\\s*(this|last|past|next)\\\\s*week)?' +\n    '(?=\\\\W|$)', 'i');\n\nvar PREFIX_GROUP = 2;\nvar WEEKDAY_GROUP = 3;\nvar POSTFIX_GROUP = 4;\n\n\nexports.updateParsedComponent = function updateParsedComponent(result, ref, offset, modifier) {\n\n    var startMoment = moment(ref);\n    var startMomentFixed = false;\n    var refOffset = startMoment.day();\n\n    if(modifier == 'last' || modifier == 'past') {\n        startMoment.day(offset - 7);\n        startMomentFixed = true;\n    } else if(modifier == 'next') {\n        startMoment.day(offset + 7);\n        startMomentFixed = true;\n    } else if(modifier == 'this') {\n        startMoment.day(offset);\n    } else {\n        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {\n            startMoment.day(offset - 7);\n        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {\n            startMoment.day(offset + 7);\n        } else {\n            startMoment.day(offset);\n        }\n    }\n\n    result.start.assign('weekday', offset);\n    if (startMomentFixed) {\n        result.start.assign('day', startMoment.date());\n        result.start.assign('month', startMoment.month() + 1);\n        result.start.assign('year', startMoment.year());\n    } else {\n        result.start.imply('day', startMoment.date());\n        result.start.imply('month', startMoment.month() + 1);\n        result.start.imply('year', startMoment.year());\n    }\n\n    return result;\n};\n\n\nexports.Parser = function ENWeekdayParser() {\n    Parser.apply(this, arguments);\n\n    this.pattern = function() { return PATTERN; };\n\n    this.extract = function(text, ref, match, opt){\n        var index = match.index + match[1].length;\n        var text = match[0].substr(match[1].length, match[0].length - match[1].length);\n        var result = new ParsedResult({\n            index: index,\n            text: text,\n            ref: ref\n        });\n\n        var dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        var offset = DAYS_OFFSET[dayOfWeek];\n        if(offset === undefined) {\n            return null;\n        }\n\n        var prefix = match[PREFIX_GROUP];\n        var postfix = match[POSTFIX_GROUP];\n        var norm = prefix || postfix;\n        norm = norm || '';\n        norm = norm.toLowerCase();\n\n        exports.updateParsedComponent(result, ref, offset, norm);\n        result.tags['ENWeekdayParser'] = true;\n\n        return result;\n    }\n};\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

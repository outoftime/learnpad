{
  "ast": null,
  "code": "/*\r\n\r\n\r\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = /(\\W|^)(maintenant|aujourd'hui|ajd|cette\\s*nuit|la\\s*veille|(demain|hier)(\\s*(matin|soir|aprem|après-midi))?|ce\\s*(matin|soir)|cet\\s*(après-midi|aprem))(?=\\W|$)/i;\n\nexports.Parser = function FRCasualDateParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var text = match[0].substr(match[1].length);\n    var index = match.index + match[1].length;\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var refMoment = moment(ref);\n    var startMoment = refMoment.clone();\n    var lowerText = text.toLowerCase();\n\n    if (lowerText.match(/demain/)) {\n      // Check not \"Tomorrow\" on late night\n      if (refMoment.hour() > 1) {\n        startMoment.add(1, 'day');\n      }\n    }\n\n    if (lowerText.match(/hier/)) {\n      startMoment.add(-1, 'day');\n    }\n\n    if (lowerText.match(/cette\\s*nuit/)) {\n      // Normally means this coming midnight\n      result.start.imply('hour', 22);\n      result.start.imply('meridiem', 1);\n    } else if (lowerText.match(/la\\s*veille/)) {\n      result.start.imply('hour', 0);\n\n      if (refMoment.hour() > 6) {\n        startMoment.add(-1, 'day');\n      }\n    } else if (lowerText.match(/(après-midi|aprem)/)) {\n      result.start.imply('hour', 14);\n    } else if (lowerText.match(/(soir)/)) {\n      result.start.imply('hour', 18);\n    } else if (lowerText.match(/matin/)) {\n      result.start.imply('hour', 8);\n    } else if (lowerText.match(\"maintenant\")) {\n      result.start.imply('hour', refMoment.hour());\n      result.start.imply('minute', refMoment.minute());\n      result.start.imply('second', refMoment.second());\n      result.start.imply('millisecond', refMoment.millisecond());\n    }\n\n    result.start.assign('day', startMoment.date());\n    result.start.assign('month', startMoment.month() + 1);\n    result.start.assign('year', startMoment.year());\n    result.tags['FRCasualDateParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/fr/FRCasualDateParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "PATTERN",
      "exports",
      "FRCasualDateParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "substr",
      "length",
      "index",
      "result",
      "refMoment",
      "startMoment",
      "clone",
      "lowerText",
      "toLowerCase",
      "hour",
      "add",
      "start",
      "imply",
      "minute",
      "second",
      "millisecond",
      "assign",
      "date",
      "month",
      "year",
      "tags"
    ],
    "mappings": "AAAA;;;;AAKA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAP,CAAqBC,MAAlC;;AACA,IAAIC,YAAY,GAAGF,OAAO,CAAC,cAAD,CAAP,CAAwBE,YAA3C;;AAEA,IAAIC,OAAO,GAAG,kKAAd;;AAEAC,OAAO,CAACH,MAAR,GAAiB,SAASI,kBAAT,GAA6B;AAE1CJ,EAAAA,MAAM,CAACK,KAAP,CAAa,IAAb,EAAmBC,SAAnB;;AAEA,OAAKC,OAAL,GAAe,YAAW;AAAE,WAAOL,OAAP;AAAiB,GAA7C;;AAEA,OAAKM,OAAL,GAAe,UAASC,IAAT,EAAeC,GAAf,EAAoBC,KAApB,EAA2BC,GAA3B,EAA+B;AAE1C,QAAIH,IAAI,GAAGE,KAAK,CAAC,CAAD,CAAL,CAASE,MAAT,CAAgBF,KAAK,CAAC,CAAD,CAAL,CAASG,MAAzB,CAAX;AACA,QAAIC,KAAK,GAAGJ,KAAK,CAACI,KAAN,GAAcJ,KAAK,CAAC,CAAD,CAAL,CAASG,MAAnC;AACA,QAAIE,MAAM,GAAG,IAAIf,YAAJ,CAAiB;AAC1Bc,MAAAA,KAAK,EAAEA,KADmB;AAE1BN,MAAAA,IAAI,EAAEA,IAFoB;AAG1BC,MAAAA,GAAG,EAAEA;AAHqB,KAAjB,CAAb;AAMA,QAAIO,SAAS,GAAGnB,MAAM,CAACY,GAAD,CAAtB;AACA,QAAIQ,WAAW,GAAGD,SAAS,CAACE,KAAV,EAAlB;AACA,QAAIC,SAAS,GAAGX,IAAI,CAACY,WAAL,EAAhB;;AAEA,QAAGD,SAAS,CAACT,KAAV,CAAgB,QAAhB,CAAH,EAA6B;AACzB;AACA,UAAGM,SAAS,CAACK,IAAV,KAAmB,CAAtB,EAAyB;AACrBJ,QAAAA,WAAW,CAACK,GAAZ,CAAgB,CAAhB,EAAmB,KAAnB;AACH;AACJ;;AAED,QAAGH,SAAS,CAACT,KAAV,CAAgB,MAAhB,CAAH,EAA4B;AACxBO,MAAAA,WAAW,CAACK,GAAZ,CAAgB,CAAC,CAAjB,EAAoB,KAApB;AACH;;AAED,QAAGH,SAAS,CAACT,KAAV,CAAgB,cAAhB,CAAH,EAAmC;AAC/B;AACAK,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AACAT,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,UAAnB,EAA+B,CAA/B;AAEH,KALD,MAKO,IAAGL,SAAS,CAACT,KAAV,CAAgB,aAAhB,CAAH,EAAmC;AAEtCK,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,CAA3B;;AACA,UAAIR,SAAS,CAACK,IAAV,KAAmB,CAAvB,EAA0B;AACtBJ,QAAAA,WAAW,CAACK,GAAZ,CAAgB,CAAC,CAAjB,EAAoB,KAApB;AACH;AAEJ,KAPM,MAOA,IAAIH,SAAS,CAACT,KAAV,CAAgB,oBAAhB,CAAJ,EAA2C;AAE9CK,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AAEH,KAJM,MAIA,IAAIL,SAAS,CAACT,KAAV,CAAgB,QAAhB,CAAJ,EAA+B;AAElCK,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AAEH,KAJM,MAIA,IAAIL,SAAS,CAACT,KAAV,CAAgB,OAAhB,CAAJ,EAA8B;AAEjCK,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,CAA3B;AAEH,KAJM,MAIC,IAAIL,SAAS,CAACT,KAAV,CAAgB,YAAhB,CAAJ,EAAmC;AAEzCK,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2BR,SAAS,CAACK,IAAV,EAA3B;AACAN,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,QAAnB,EAA6BR,SAAS,CAACS,MAAV,EAA7B;AACAV,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,QAAnB,EAA6BR,SAAS,CAACU,MAAV,EAA7B;AACAX,MAAAA,MAAM,CAACQ,KAAP,CAAaC,KAAb,CAAmB,aAAnB,EAAkCR,SAAS,CAACW,WAAV,EAAlC;AAED;;AAEDZ,IAAAA,MAAM,CAACQ,KAAP,CAAaK,MAAb,CAAoB,KAApB,EAA2BX,WAAW,CAACY,IAAZ,EAA3B;AACAd,IAAAA,MAAM,CAACQ,KAAP,CAAaK,MAAb,CAAoB,OAApB,EAA6BX,WAAW,CAACa,KAAZ,KAAsB,CAAnD;AACAf,IAAAA,MAAM,CAACQ,KAAP,CAAaK,MAAb,CAAoB,MAApB,EAA4BX,WAAW,CAACc,IAAZ,EAA5B;AACAhB,IAAAA,MAAM,CAACiB,IAAP,CAAY,oBAAZ,IAAoC,IAApC;AACA,WAAOjB,MAAP;AACH,GA/DD;AAgEH,CAtED",
    "sourcesContent": [
      "/*\r\n\r\n\r\n*/\r\n\r\nvar moment = require('moment');\r\nvar Parser = require('../parser').Parser;\r\nvar ParsedResult = require('../../result').ParsedResult;\r\n\r\nvar PATTERN = /(\\W|^)(maintenant|aujourd'hui|ajd|cette\\s*nuit|la\\s*veille|(demain|hier)(\\s*(matin|soir|aprem|après-midi))?|ce\\s*(matin|soir)|cet\\s*(après-midi|aprem))(?=\\W|$)/i;\r\n\r\nexports.Parser = function FRCasualDateParser(){\r\n\r\n    Parser.apply(this, arguments);\r\n\r\n    this.pattern = function() { return PATTERN; }\r\n\r\n    this.extract = function(text, ref, match, opt){\r\n\r\n        var text = match[0].substr(match[1].length);\r\n        var index = match.index + match[1].length;\r\n        var result = new ParsedResult({\r\n            index: index,\r\n            text: text,\r\n            ref: ref,\r\n        });\r\n\r\n        var refMoment = moment(ref);\r\n        var startMoment = refMoment.clone();\r\n        var lowerText = text.toLowerCase();\r\n\r\n        if(lowerText.match(/demain/)){\r\n            // Check not \"Tomorrow\" on late night\r\n            if(refMoment.hour() > 1) {\r\n                startMoment.add(1, 'day');\r\n            }\r\n        } \r\n\r\n        if(lowerText.match(/hier/)) {\r\n            startMoment.add(-1, 'day');\r\n        }\r\n\r\n        if(lowerText.match(/cette\\s*nuit/)){\r\n            // Normally means this coming midnight\r\n            result.start.imply('hour', 22);\r\n            result.start.imply('meridiem', 1);\r\n\r\n        } else if(lowerText.match(/la\\s*veille/)) {\r\n\r\n            result.start.imply('hour', 0);\r\n            if (refMoment.hour() > 6) {\r\n                startMoment.add(-1, 'day');\r\n            }\r\n\r\n        } else if (lowerText.match(/(après-midi|aprem)/)) {\r\n\r\n            result.start.imply('hour', 14);\r\n\r\n        } else if (lowerText.match(/(soir)/)) {\r\n\r\n            result.start.imply('hour', 18);\r\n\r\n        } else if (lowerText.match(/matin/)) {\r\n\r\n            result.start.imply('hour', 8);\r\n\r\n        }  else if (lowerText.match(\"maintenant\")) {\r\n\r\n          result.start.imply('hour', refMoment.hour());\r\n          result.start.imply('minute', refMoment.minute());\r\n          result.start.imply('second', refMoment.second());\r\n          result.start.imply('millisecond', refMoment.millisecond());\r\n\r\n        }\r\n\r\n        result.start.assign('day', startMoment.date())\r\n        result.start.assign('month', startMoment.month() + 1)\r\n        result.start.assign('year', startMoment.year())\r\n        result.tags['FRCasualDateParser'] = true;\r\n        return result;\r\n    }\r\n}\r\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

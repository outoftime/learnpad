{
  "ast": null,
  "code": "/*\n\n*/\nvar ParsedComponents = require('../../result').ParsedComponents;\n\nvar Refiner = require('../refiner').Refiner;\n\nvar PATTERN = new RegExp(\"^\\\\s*(at|after|before|on|,|-|\\\\(|\\\\))?\\\\s*$\");\n\nfunction isMoreSpecific(prevResult, currResult) {\n  var moreSpecific = false;\n\n  if (prevResult.start.isCertain('year')) {\n    if (!currResult.start.isCertain('year')) {\n      moreSpecific = true;\n    } else {\n      if (prevResult.start.isCertain('month')) {\n        if (!currResult.start.isCertain('month')) {\n          moreSpecific = true;\n        } else {\n          if (prevResult.start.isCertain('day') && !currResult.start.isCertain('day')) {\n            moreSpecific = true;\n          }\n        }\n      }\n    }\n  }\n\n  return moreSpecific;\n}\n\nfunction isAbleToMerge(text, prevResult, currResult) {\n  var textBetween = text.substring(prevResult.index + prevResult.text.length, currResult.index); // Only accepts merge if one of them comes from casual relative date\n\n  var includesRelativeResult = prevResult.tags['ENRelativeDateFormatParser'] || currResult.tags['ENRelativeDateFormatParser']; // We assume they refer to the same date if all date fields are implied\n\n  var referToSameDate = !prevResult.start.isCertain('day') && !prevResult.start.isCertain('month') && !prevResult.start.isCertain('year'); // If both years are certain, that determines if they refer to the same date\n  // but with one more specific than the other\n\n  if (prevResult.start.isCertain('year') && currResult.start.isCertain('year')) referToSameDate = prevResult.start.get('year') === currResult.start.get('year'); // We now test with the next level (month) if they refer to the same date\n\n  if (prevResult.start.isCertain('month') && currResult.start.isCertain('month')) referToSameDate = prevResult.start.get('month') === currResult.start.get('month') && referToSameDate;\n  return includesRelativeResult && textBetween.match(PATTERN) && referToSameDate;\n}\n\nfunction mergeResult(text, specificResult, nonSpecificResult) {\n  var specificDate = specificResult.start;\n  var nonSpecificDate = nonSpecificResult.start;\n  var startIndex = Math.min(specificResult.index, nonSpecificResult.index);\n  var endIndex = Math.max(specificResult.index + specificResult.text.length, nonSpecificResult.index + nonSpecificResult.text.length);\n  specificResult.index = startIndex;\n  specificResult.text = text.substring(startIndex, endIndex);\n\n  for (var tag in nonSpecificResult.tags) {\n    specificResult.tags[tag] = true;\n  }\n\n  specificResult.tags['ENPrioritizeSpecificDateRefiner'] = true;\n  return specificResult;\n}\n\nexports.Refiner = function ENPrioritizeSpecificDateRefiner() {\n  Refiner.call(this);\n\n  this.refine = function (text, results, opt) {\n    if (results.length < 2) return results;\n    var mergedResult = [];\n    var currResult = null;\n    var prevResult = null;\n\n    for (var i = 1; i < results.length; i++) {\n      currResult = results[i];\n      prevResult = results[i - 1];\n\n      if (isMoreSpecific(prevResult, currResult) && isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = mergeResult(text, prevResult, currResult);\n        currResult = null;\n        i += 1;\n      } else if (isMoreSpecific(currResult, prevResult) && isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = mergeResult(text, currResult, prevResult);\n        currResult = null;\n        i += 1;\n      }\n\n      mergedResult.push(prevResult);\n    }\n\n    if (currResult != null) {\n      mergedResult.push(currResult);\n    }\n\n    return mergedResult;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/refiners/en/ENPrioritizeSpecificDateRefiner.js"
    ],
    "names": [
      "ParsedComponents",
      "require",
      "Refiner",
      "PATTERN",
      "RegExp",
      "isMoreSpecific",
      "prevResult",
      "currResult",
      "moreSpecific",
      "start",
      "isCertain",
      "isAbleToMerge",
      "text",
      "textBetween",
      "substring",
      "index",
      "length",
      "includesRelativeResult",
      "tags",
      "referToSameDate",
      "get",
      "match",
      "mergeResult",
      "specificResult",
      "nonSpecificResult",
      "specificDate",
      "nonSpecificDate",
      "startIndex",
      "Math",
      "min",
      "endIndex",
      "max",
      "tag",
      "exports",
      "ENPrioritizeSpecificDateRefiner",
      "call",
      "refine",
      "results",
      "opt",
      "mergedResult",
      "i",
      "push"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n\n*/\nvar ParsedComponents = require('../../result').ParsedComponents;\nvar Refiner = require('../refiner').Refiner;\n\n\nvar PATTERN = new RegExp(\"^\\\\s*(at|after|before|on|,|-|\\\\(|\\\\))?\\\\s*$\");\n\nfunction isMoreSpecific(prevResult, currResult) {\n    var moreSpecific = false;\n\n    if (prevResult.start.isCertain('year')) {\n        if (!currResult.start.isCertain('year')) {\n            moreSpecific = true;\n        } else {\n            if (prevResult.start.isCertain('month')) {\n                if (!currResult.start.isCertain('month')) {\n                    moreSpecific = true;\n                } else {\n                    if (prevResult.start.isCertain('day') && !currResult.start.isCertain('day')) {\n                        moreSpecific = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return moreSpecific;\n}\n\n\nfunction isAbleToMerge(text, prevResult, currResult) {\n    var textBetween = text.substring(prevResult.index + prevResult.text.length, currResult.index);\n\n    // Only accepts merge if one of them comes from casual relative date\n    var includesRelativeResult = (prevResult.tags['ENRelativeDateFormatParser'] || currResult.tags['ENRelativeDateFormatParser']);\n\n    // We assume they refer to the same date if all date fields are implied\n    var referToSameDate = !prevResult.start.isCertain('day') && !prevResult.start.isCertain('month') && !prevResult.start.isCertain('year');\n\n    // If both years are certain, that determines if they refer to the same date\n    // but with one more specific than the other\n    if (prevResult.start.isCertain('year') && currResult.start.isCertain('year'))\n        referToSameDate = (prevResult.start.get('year') === currResult.start.get('year'));\n\n    // We now test with the next level (month) if they refer to the same date\n    if (prevResult.start.isCertain('month') && currResult.start.isCertain('month'))\n        referToSameDate = (prevResult.start.get('month') === currResult.start.get('month')) && referToSameDate;\n\n    return includesRelativeResult && textBetween.match(PATTERN) && referToSameDate;\n}\n\nfunction mergeResult(text, specificResult, nonSpecificResult){\n\n    var specificDate = specificResult.start;\n    var nonSpecificDate = nonSpecificResult.start;\n\n    var startIndex = Math.min(specificResult.index, nonSpecificResult.index);\n    var endIndex = Math.max(\n            specificResult.index + specificResult.text.length,\n            nonSpecificResult.index + nonSpecificResult.text.length);\n\n    specificResult.index = startIndex;\n    specificResult.text  = text.substring(startIndex, endIndex);\n\n    for (var tag in nonSpecificResult.tags) {\n        specificResult.tags[tag] = true;\n    }\n    specificResult.tags['ENPrioritizeSpecificDateRefiner'] = true;\n    return specificResult;\n}\n\nexports.Refiner = function ENPrioritizeSpecificDateRefiner() {\n    Refiner.call(this);\n\n    this.refine = function(text, results, opt) {\n\n        if (results.length < 2) return results;\n\n        var mergedResult = [];\n        var currResult = null;\n        var prevResult = null;\n\n        for (var i = 1; i < results.length; i++) {\n\n            currResult = results[i];\n            prevResult = results[i-1];\n\n            if (isMoreSpecific(prevResult, currResult)\n                    && isAbleToMerge(text, prevResult, currResult)) {\n\n                prevResult = mergeResult(text, prevResult, currResult);\n                currResult = null;\n                i += 1;\n\n            } else if (isMoreSpecific(currResult, prevResult)\n                    && isAbleToMerge(text, prevResult, currResult)) {\n\n                prevResult = mergeResult(text, currResult, prevResult);\n                currResult = null;\n                i += 1;\n            }\n\n            mergedResult.push(prevResult);\n        }\n\n        if (currResult != null) {\n            mergedResult.push(currResult);\n        }\n\n        return mergedResult;\n    }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

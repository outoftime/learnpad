{
  "ast": null,
  "code": "/*\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar ParsedComponents = require('../../result').ParsedComponents;\n\nvar FIRST_REG_PATTERN = new RegExp(\"(^|\\\\s|T)\" + \"(?:(?:at|from)\\\\s*)??\" + \"(\\\\d{1,4}|noon|midnight)\" + \"(?:\" + \"(?:\\\\.|\\\\:|\\\\：)(\\\\d{1,2})\" + \"(?:\" + \"(?:\\\\:|\\\\：)(\\\\d{2})(?:\\\\.(\\\\d{1,6}))?\" + \")?\" + \")?\" + \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?|O\\\\W*CLOCK))?\" + \"(?=\\\\W|$)\", 'i');\nvar SECOND_REG_PATTERN = new RegExp(\"^\\\\s*\" + \"(\\\\-|\\\\–|\\\\~|\\\\〜|to|\\\\?)\\\\s*\" + \"(\\\\d{1,4})\" + \"(?:\" + \"(?:\\\\.|\\\\:|\\\\：)(\\\\d{1,2})\" + \"(?:\" + \"(?:\\\\.|\\\\:|\\\\：)(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?\" + \")?\" + \")?\" + \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?|O\\\\W*CLOCK))?\" + \"(?=\\\\W|$)\", 'i');\nvar HOUR_GROUP = 2;\nvar MINUTE_GROUP = 3;\nvar SECOND_GROUP = 4;\nvar MILLI_SECOND_GROUP = 5;\nvar AM_PM_HOUR_GROUP = 6;\n\nexports.Parser = function ENTimeExpressionParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return FIRST_REG_PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    // This pattern can be overlapped Ex. [12] AM, 1[2] AM\n    if (match.index > 0 && text[match.index - 1].match(/\\w/)) return null;\n    var refMoment = moment(ref);\n    var result = new ParsedResult();\n    result.ref = ref;\n    result.index = match.index + match[1].length;\n    result.text = match[0].substring(match[1].length);\n    result.tags['ENTimeExpressionParser'] = true;\n    result.start.imply('day', refMoment.date());\n    result.start.imply('month', refMoment.month() + 1);\n    result.start.imply('year', refMoment.year());\n    var hour = 0;\n    var minute = 0;\n    var meridiem = -1; // ----- Millisecond\n\n    if (match[MILLI_SECOND_GROUP] != null) {\n      var millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n      if (millisecond >= 1000) return null;\n      result.start.assign('millisecond', millisecond);\n    } // ----- Second\n\n\n    if (match[SECOND_GROUP] != null) {\n      var second = parseInt(match[SECOND_GROUP]);\n      if (second >= 60) return null;\n      result.start.assign('second', second);\n    } // ----- Hours\n\n\n    if (match[HOUR_GROUP].toLowerCase() == \"noon\") {\n      meridiem = 1;\n      hour = 12;\n    } else if (match[HOUR_GROUP].toLowerCase() == \"midnight\") {\n      meridiem = 0;\n      hour = 0;\n    } else {\n      hour = parseInt(match[HOUR_GROUP]);\n    } // ----- Minutes\n\n\n    if (match[MINUTE_GROUP] != null) {\n      minute = parseInt(match[MINUTE_GROUP]);\n    } else if (hour > 100) {\n      minute = hour % 100;\n      hour = parseInt(hour / 100);\n    }\n\n    if (minute >= 60) {\n      return null;\n    }\n\n    if (hour > 24) {\n      return null;\n    }\n\n    if (hour >= 12) {\n      meridiem = 1;\n    } // ----- AM & PM  \n\n\n    if (match[AM_PM_HOUR_GROUP] != null) {\n      if (hour > 12) return null;\n      var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n\n      if (ampm == \"a\") {\n        meridiem = 0;\n        if (hour == 12) hour = 0;\n      }\n\n      if (ampm == \"p\") {\n        meridiem = 1;\n        if (hour != 12) hour += 12;\n      }\n    }\n\n    result.start.assign('hour', hour);\n    result.start.assign('minute', minute);\n\n    if (meridiem >= 0) {\n      result.start.assign('meridiem', meridiem);\n    } else {\n      if (hour < 12) {\n        result.start.imply('meridiem', 0);\n      } else {\n        result.start.imply('meridiem', 1);\n      }\n    } // ==============================================================\n    //                  Extracting the 'to' chunk\n    // ==============================================================\n\n\n    match = SECOND_REG_PATTERN.exec(text.substring(result.index + result.text.length));\n\n    if (!match) {\n      return result;\n    } // Pattern \"YY.YY -XXXX\" is more like timezone offset\n\n\n    if (match[0].match(/^\\s*(\\+|\\-)\\s*\\d{3,4}$/)) {\n      return result;\n    }\n\n    if (result.end == null) {\n      result.end = new ParsedComponents(null, result.start.date());\n    }\n\n    var hour = 0;\n    var minute = 0;\n    var meridiem = -1; // ----- Millisecond\n\n    if (match[MILLI_SECOND_GROUP] != null) {\n      var millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n      if (millisecond >= 1000) return null;\n      result.end.assign('millisecond', millisecond);\n    } // ----- Second\n\n\n    if (match[SECOND_GROUP] != null) {\n      var second = parseInt(match[SECOND_GROUP]);\n      if (second >= 60) return null;\n      result.end.assign('second', second);\n    }\n\n    hour = parseInt(match[2]); // ----- Minute\n\n    if (match[MINUTE_GROUP] != null) {\n      minute = parseInt(match[MINUTE_GROUP]);\n      if (minute >= 60) return result;\n    } else if (hour > 100) {\n      minute = hour % 100;\n      hour = parseInt(hour / 100);\n    }\n\n    if (minute >= 60) {\n      return null;\n    }\n\n    if (hour > 24) {\n      return null;\n    }\n\n    if (hour >= 12) {\n      meridiem = 1;\n    } // ----- AM & PM \n\n\n    if (match[AM_PM_HOUR_GROUP] != null) {\n      if (hour > 12) return null;\n      var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n\n      if (ampm == \"a\") {\n        meridiem = 0;\n\n        if (hour == 12) {\n          hour = 0;\n\n          if (!result.end.isCertain('day')) {\n            result.end.imply('day', result.end.get('day') + 1);\n          }\n        }\n      }\n\n      if (ampm == \"p\") {\n        meridiem = 1;\n        if (hour != 12) hour += 12;\n      }\n\n      if (!result.start.isCertain('meridiem')) {\n        if (meridiem == 0) {\n          result.start.imply('meridiem', 0);\n\n          if (result.start.get('hour') == 12) {\n            result.start.assign('hour', 0);\n          }\n        } else {\n          result.start.imply('meridiem', 1);\n\n          if (result.start.get('hour') != 12) {\n            result.start.assign('hour', result.start.get('hour') + 12);\n          }\n        }\n      }\n    }\n\n    result.text = result.text + match[0];\n    result.end.assign('hour', hour);\n    result.end.assign('minute', minute);\n\n    if (meridiem >= 0) {\n      result.end.assign('meridiem', meridiem);\n    } else {\n      var startAtPM = result.start.isCertain('meridiem') && result.start.get('meridiem') == 1;\n\n      if (startAtPM && result.start.get('hour') > hour) {\n        // 10pm - 1 (am)\n        result.end.imply('meridiem', 0);\n      } else if (hour > 12) {\n        result.end.imply('meridiem', 1);\n      }\n    }\n\n    if (result.end.date().getTime() < result.start.date().getTime()) {\n      result.end.imply('day', result.end.get('day') + 1);\n    }\n\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/en/ENTimeExpressionParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "ParsedComponents",
      "FIRST_REG_PATTERN",
      "RegExp",
      "SECOND_REG_PATTERN",
      "HOUR_GROUP",
      "MINUTE_GROUP",
      "SECOND_GROUP",
      "MILLI_SECOND_GROUP",
      "AM_PM_HOUR_GROUP",
      "exports",
      "ENTimeExpressionParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "index",
      "refMoment",
      "result",
      "length",
      "substring",
      "tags",
      "start",
      "imply",
      "date",
      "month",
      "year",
      "hour",
      "minute",
      "meridiem",
      "millisecond",
      "parseInt",
      "assign",
      "second",
      "toLowerCase",
      "ampm",
      "exec",
      "end",
      "isCertain",
      "get",
      "startAtPM",
      "getTime"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n\n*/\n\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\nvar ParsedComponents = require('../../result').ParsedComponents;\n\nvar FIRST_REG_PATTERN  = new RegExp(\"(^|\\\\s|T)\" +\n    \"(?:(?:at|from)\\\\s*)??\" + \n    \"(\\\\d{1,4}|noon|midnight)\" + \n    \"(?:\" + \n        \"(?:\\\\.|\\\\:|\\\\：)(\\\\d{1,2})\" + \n        \"(?:\" + \n            \"(?:\\\\:|\\\\：)(\\\\d{2})(?:\\\\.(\\\\d{1,6}))?\" + \n        \")?\" + \n    \")?\" + \n    \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?|O\\\\W*CLOCK))?\" + \n    \"(?=\\\\W|$)\", 'i');\n\n\nvar SECOND_REG_PATTERN = new RegExp(\"^\\\\s*\" + \n    \"(\\\\-|\\\\–|\\\\~|\\\\〜|to|\\\\?)\\\\s*\" + \n    \"(\\\\d{1,4})\" +\n    \"(?:\" + \n        \"(?:\\\\.|\\\\:|\\\\：)(\\\\d{1,2})\" + \n        \"(?:\" + \n            \"(?:\\\\.|\\\\:|\\\\：)(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?\" + \n        \")?\" + \n    \")?\" + \n    \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?|O\\\\W*CLOCK))?\" + \n    \"(?=\\\\W|$)\", 'i');\n\nvar HOUR_GROUP    = 2;\nvar MINUTE_GROUP  = 3;\nvar SECOND_GROUP  = 4;\nvar MILLI_SECOND_GROUP  = 5;\nvar AM_PM_HOUR_GROUP = 6;\n\n\nexports.Parser = function ENTimeExpressionParser(){\n    Parser.apply(this, arguments);\n\n    this.pattern = function() { return FIRST_REG_PATTERN; }\n    \n    this.extract = function(text, ref, match, opt){ \n        \n        // This pattern can be overlapped Ex. [12] AM, 1[2] AM\n        if (match.index > 0 && text[match.index-1].match(/\\w/)) return null;\n        var refMoment = moment(ref);\n        var result = new ParsedResult();\n        result.ref = ref;\n        result.index = match.index + match[1].length;\n        result.text  = match[0].substring(match[1].length);\n        result.tags['ENTimeExpressionParser'] = true;\n\n        result.start.imply('day',   refMoment.date());\n        result.start.imply('month', refMoment.month()+1);\n        result.start.imply('year',  refMoment.year());\n        \n        var hour = 0;\n        var minute = 0;\n        var meridiem = -1;\n\n        // ----- Millisecond\n        if(match[MILLI_SECOND_GROUP] != null){ \n            var millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if(millisecond >= 1000) return null;\n            \n            result.start.assign('millisecond', millisecond);\n        }\n\n        // ----- Second\n        if(match[SECOND_GROUP] != null){ \n            var second = parseInt(match[SECOND_GROUP]);\n            if(second >= 60) return null;\n\n            result.start.assign('second', second);\n        }\n        \n        // ----- Hours\n        if (match[HOUR_GROUP].toLowerCase() == \"noon\"){\n            meridiem = 1; \n            hour = 12;\n        } else if (match[HOUR_GROUP].toLowerCase() == \"midnight\") {\n            meridiem = 0; \n            hour = 0;\n        } else {\n            hour = parseInt(match[HOUR_GROUP]);\n        }\n        \n        // ----- Minutes\n        if(match[MINUTE_GROUP] != null){ \n            minute = parseInt(match[MINUTE_GROUP]);\n        } else if(hour > 100) { \n            minute = hour%100;\n            hour   = parseInt(hour/100);\n        } \n        \n        if(minute >= 60) {\n            return null;\n        }\n\n        if(hour > 24) {\n            return null;\n        }\n        if (hour >= 12) { \n            meridiem = 1;\n        }\n\n        // ----- AM & PM  \n        if(match[AM_PM_HOUR_GROUP] != null) {\n            if(hour > 12) return null;\n            var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if(ampm == \"a\"){\n                meridiem = 0; \n                if(hour == 12) hour = 0;\n            }\n            \n            if(ampm == \"p\"){\n                meridiem = 1; \n                if(hour != 12) hour += 12;\n            }\n        } \n\n        result.start.assign('hour', hour);\n        result.start.assign('minute', minute);\n\n        if (meridiem >= 0) {\n            result.start.assign('meridiem', meridiem);\n        } else {\n            if (hour < 12) {\n                result.start.imply('meridiem', 0);\n            } else {\n                result.start.imply('meridiem', 1);\n            }\n        }\n\n        // ==============================================================\n        //                  Extracting the 'to' chunk\n        // ==============================================================\n        match = SECOND_REG_PATTERN.exec(text.substring(result.index + result.text.length));\n        if (!match) {\n            return result;\n        }\n\n\n\n        // Pattern \"YY.YY -XXXX\" is more like timezone offset\n        if (match[0].match(/^\\s*(\\+|\\-)\\s*\\d{3,4}$/)) {\n            return result;\n        }\n\n        if(result.end == null){\n            result.end = new ParsedComponents(null, result.start.date());\n        }\n\n        var hour = 0;\n        var minute = 0;\n        var meridiem = -1;\n\n        // ----- Millisecond\n        if(match[MILLI_SECOND_GROUP] != null){ \n            var millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if(millisecond >= 1000) return null;\n            \n            result.end.assign('millisecond', millisecond);\n        }\n        \n        // ----- Second\n        if(match[SECOND_GROUP] != null){ \n            var second = parseInt(match[SECOND_GROUP]);\n            if(second >= 60) return null;\n\n            result.end.assign('second', second);\n        }\n\n        hour = parseInt(match[2]);\n        \n        // ----- Minute\n        if (match[MINUTE_GROUP]!= null) {\n            \n            minute = parseInt(match[MINUTE_GROUP]);\n            if(minute >= 60) return result;\n            \n        } else if (hour > 100) {\n\n            minute = hour%100;\n            hour   = parseInt(hour/100);\n        }\n\n        if(minute >= 60) {\n            return null;\n        }\n\n        if(hour > 24) {\n            return null;\n        }\n        if (hour >= 12) { \n            meridiem = 1;\n        }\n        \n        // ----- AM & PM \n        if (match[AM_PM_HOUR_GROUP] != null){\n\n            if (hour > 12) return null;\n\n            var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if(ampm == \"a\"){\n                meridiem = 0; \n                if(hour == 12) {\n                    hour = 0;\n                    if (!result.end.isCertain('day')) {\n                        result.end.imply('day', result.end.get('day') + 1);\n                    }\n                }\n            }\n            \n            if(ampm == \"p\"){\n                meridiem = 1; \n                if(hour != 12) hour += 12;\n            }\n            \n            if (!result.start.isCertain('meridiem')) {\n                if (meridiem == 0) {\n                    \n                    result.start.imply('meridiem', 0);\n                    \n                    if (result.start.get('hour') == 12) {\n                        result.start.assign('hour', 0);\n                    }\n\n                } else {\n\n                    result.start.imply('meridiem', 1);\n                    \n                    if (result.start.get('hour') != 12) {\n                        result.start.assign('hour', result.start.get('hour') + 12); \n                    }\n                }\n            }\n        }\n\n        result.text = result.text + match[0];\n        result.end.assign('hour', hour);\n        result.end.assign('minute', minute);\n        if (meridiem >= 0) {\n            result.end.assign('meridiem', meridiem);\n        } else {\n            var startAtPM = result.start.isCertain('meridiem') && result.start.get('meridiem') == 1;\n            if (startAtPM && result.start.get('hour') > hour) {\n                // 10pm - 1 (am)\n                result.end.imply('meridiem', 0);\n\n            } else if (hour > 12) {\n                result.end.imply('meridiem', 1);\n            }\n        }\n\n        if (result.end.date().getTime() < result.start.date().getTime()) {\n            result.end.imply('day', result.end.get('day') + 1)\n        }\n        \n        return result;\n    }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

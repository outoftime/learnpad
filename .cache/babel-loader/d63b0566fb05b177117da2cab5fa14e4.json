{
  "ast": null,
  "code": "/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/EN');\n\nvar PATTERN = new RegExp('(\\\\W|^)' + '(?:on\\\\s*?)?' + '(?:(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\\\s*,?\\\\s*)?' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + util.ORDINAL_WORDS_PATTERN + ')' + '(?:\\\\s*' + '(?:to|\\\\-|\\\\–|until|through|till|\\\\s)\\\\s*' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + util.ORDINAL_WORDS_PATTERN + ')' + ')?' + '(?:-|\\/|\\\\s*(?:of)?\\\\s*)' + '(' + util.MONTH_PATTERN + ')' + '(?:' + '(?:-|\\/|,?\\\\s*)' + '((?:' + '[1-9][0-9]{0,3}\\\\s*(?:BE|AD|BC)|' + '[1-2][0-9]{3}' + ')(?![^\\\\s]\\\\d))' + ')?' + '(?=\\\\W|$)', 'i');\nvar WEEKDAY_GROUP = 2;\nvar DATE_GROUP = 3;\nvar DATE_NUM_GROUP = 4;\nvar DATE_TO_GROUP = 5;\nvar DATE_TO_NUM_GROUP = 6;\nvar MONTH_NAME_GROUP = 7;\nvar YEAR_GROUP = 8;\n\nexports.Parser = function ENMonthNameLittleEndianParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var result = new ParsedResult({\n      text: match[0].substr(match[1].length, match[0].length - match[1].length),\n      index: match.index + match[1].length,\n      ref: ref\n    });\n    var month = match[MONTH_NAME_GROUP];\n    month = util.MONTH_OFFSET[month.toLowerCase()];\n    var day = match[DATE_NUM_GROUP] ? parseInt(match[DATE_NUM_GROUP]) : util.ORDINAL_WORDS[match[DATE_GROUP].trim().replace('-', ' ').toLowerCase()];\n    var year = null;\n\n    if (match[YEAR_GROUP]) {\n      year = match[YEAR_GROUP];\n\n      if (/BE/i.test(year)) {\n        // Buddhist Era\n        year = year.replace(/BE/i, '');\n        year = parseInt(year) - 543;\n      } else if (/BC/i.test(year)) {\n        // Before Christ\n        year = year.replace(/BC/i, '');\n        year = -parseInt(year);\n      } else if (/AD/i.test(year)) {\n        year = year.replace(/AD/i, '');\n        year = parseInt(year);\n      } else {\n        year = parseInt(year);\n\n        if (year < 100) {\n          year = year + 2000;\n        }\n      }\n    }\n\n    if (year) {\n      result.start.assign('day', day);\n      result.start.assign('month', month);\n      result.start.assign('year', year);\n    } else {\n      //Find the most appropriated year\n      var refMoment = moment(ref);\n      refMoment.month(month - 1);\n      refMoment.date(day);\n      refMoment.year(moment(ref).year());\n      var nextYear = refMoment.clone().add(1, 'y');\n      var lastYear = refMoment.clone().add(-1, 'y');\n\n      if (Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = nextYear;\n      } else if (Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = lastYear;\n      }\n\n      result.start.assign('day', day);\n      result.start.assign('month', month);\n      result.start.imply('year', refMoment.year());\n    } // Weekday component\n\n\n    if (match[WEEKDAY_GROUP]) {\n      var weekday = match[WEEKDAY_GROUP];\n      weekday = util.WEEKDAY_OFFSET[weekday.toLowerCase()];\n      result.start.assign('weekday', weekday);\n    } // Text can be 'range' value. Such as '12 - 13 January 2012'\n\n\n    if (match[DATE_TO_GROUP]) {\n      var endDate = match[DATE_TO_NUM_GROUP] ? parseInt(match[DATE_TO_NUM_GROUP]) : util.ORDINAL_WORDS[match[DATE_TO_GROUP].trim().replace('-', ' ').toLowerCase()];\n      result.end = result.start.clone();\n      result.end.assign('day', endDate);\n    }\n\n    result.tags['ENMonthNameLittleEndianParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/en/ENMonthNameLittleEndianParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "util",
      "PATTERN",
      "RegExp",
      "ORDINAL_WORDS_PATTERN",
      "MONTH_PATTERN",
      "WEEKDAY_GROUP",
      "DATE_GROUP",
      "DATE_NUM_GROUP",
      "DATE_TO_GROUP",
      "DATE_TO_NUM_GROUP",
      "MONTH_NAME_GROUP",
      "YEAR_GROUP",
      "exports",
      "ENMonthNameLittleEndianParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "result",
      "substr",
      "length",
      "index",
      "month",
      "MONTH_OFFSET",
      "toLowerCase",
      "day",
      "parseInt",
      "ORDINAL_WORDS",
      "trim",
      "replace",
      "year",
      "test",
      "start",
      "assign",
      "refMoment",
      "date",
      "nextYear",
      "clone",
      "add",
      "lastYear",
      "Math",
      "abs",
      "diff",
      "imply",
      "weekday",
      "WEEKDAY_OFFSET",
      "endDate",
      "end",
      "tags"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n\n\n*/\n\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\nvar util  = require('../../utils/EN');\n\nvar PATTERN = new RegExp('(\\\\W|^)' +\n        '(?:on\\\\s*?)?' +\n        '(?:(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\\\s*,?\\\\s*)?' +\n        '(([0-9]{1,2})(?:st|nd|rd|th)?|' + util.ORDINAL_WORDS_PATTERN + ')' +\n        '(?:\\\\s*' +\n            '(?:to|\\\\-|\\\\–|until|through|till|\\\\s)\\\\s*' +\n            '(([0-9]{1,2})(?:st|nd|rd|th)?|' + util.ORDINAL_WORDS_PATTERN + ')' +\n        ')?' + \n        '(?:-|\\/|\\\\s*(?:of)?\\\\s*)' +\n        '(' + util.MONTH_PATTERN + ')' +\n        '(?:' +\n            '(?:-|\\/|,?\\\\s*)' +\n            '((?:' + \n                '[1-9][0-9]{0,3}\\\\s*(?:BE|AD|BC)|' +\n                '[1-2][0-9]{3}' + \n            ')(?![^\\\\s]\\\\d))' +\n        ')?' +\n        '(?=\\\\W|$)', 'i'\n    );\n\nvar WEEKDAY_GROUP = 2;\nvar DATE_GROUP = 3;\nvar DATE_NUM_GROUP = 4;\nvar DATE_TO_GROUP = 5;\nvar DATE_TO_NUM_GROUP = 6;\nvar MONTH_NAME_GROUP = 7;\nvar YEAR_GROUP = 8;\n\nexports.Parser = function ENMonthNameLittleEndianParser(){\n    Parser.apply(this, arguments);\n\n    this.pattern = function() { return PATTERN; }\n\n    this.extract = function(text, ref, match, opt){\n\n        var result = new ParsedResult({\n            text: match[0].substr(match[1].length, match[0].length - match[1].length),\n            index: match.index + match[1].length,\n            ref: ref\n        });\n\n        var month = match[MONTH_NAME_GROUP];\n        month = util.MONTH_OFFSET[month.toLowerCase()];\n\n        var day = match[DATE_NUM_GROUP] ?\n            parseInt(match[DATE_NUM_GROUP]):\n            util.ORDINAL_WORDS[match[DATE_GROUP].trim().replace('-', ' ').toLowerCase()];\n\n        var year = null;\n        if (match[YEAR_GROUP]) {\n            year = match[YEAR_GROUP];\n            \n            if (/BE/i.test(year)) {\n                // Buddhist Era\n                year = year.replace(/BE/i, '');\n                year = parseInt(year) - 543;\n            } else if (/BC/i.test(year)){\n                // Before Christ\n                year = year.replace(/BC/i, '');\n                year = -parseInt(year);\n            } else if (/AD/i.test(year)){\n                year = year.replace(/AD/i, '');\n                year = parseInt(year);\n            } else {\n                year = parseInt(year);\n                if (year < 100){\n                    year = year + 2000;\n                }\n            }\n        }\n\n        if(year){\n            result.start.assign('day', day);\n            result.start.assign('month', month);\n            result.start.assign('year', year);\n        } else {\n\n            //Find the most appropriated year\n            var refMoment = moment(ref);\n            refMoment.month(month - 1);\n            refMoment.date(day);\n            refMoment.year(moment(ref).year());\n\n            var nextYear = refMoment.clone().add(1, 'y');\n            var lastYear = refMoment.clone().add(-1, 'y');\n            if( Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref))) ){\n                refMoment = nextYear;\n            }\n            else if( Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref))) ){\n                refMoment = lastYear;\n            }\n\n            result.start.assign('day', day);\n            result.start.assign('month', month);\n            result.start.imply('year', refMoment.year());\n        }\n\n        // Weekday component\n        if (match[WEEKDAY_GROUP]) {\n            var weekday = match[WEEKDAY_GROUP];\n            weekday = util.WEEKDAY_OFFSET[weekday.toLowerCase()]\n            result.start.assign('weekday', weekday);\n        }\n\n        // Text can be 'range' value. Such as '12 - 13 January 2012'\n        if (match[DATE_TO_GROUP]) {\n            var endDate = match[DATE_TO_NUM_GROUP] ?\n                parseInt(match[DATE_TO_NUM_GROUP]):\n                util.ORDINAL_WORDS[match[DATE_TO_GROUP].trim().replace('-', ' ').toLowerCase()];\n\n            result.end = result.start.clone();\n            result.end.assign('day', endDate);\n        }\n\n        result.tags['ENMonthNameLittleEndianParser'] = true;\n        return result;\n    };\n};\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

{
  "ast": null,
  "code": "function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// If any spare unopened tag exists afterward, diagnose it and only yield\n// MISPLACED_CLOSE_TAG.\n//\n// Otherwise:\n//\n// A mismatched close tag that has been opened means the case\n//\n// <div>\n//   <span>\n// </div>\n//\n// so yield UNCLOSED_TAG.\n//\n// A mismatched close tag that has yet to be opened means the case\n//\n// <div>\n//   </span>\n// </div>\n//\n// so yield UNOPENED_TAG.\nimport findLastIndex from 'lodash-es/findLastIndex';\nimport Code from './Code';\n\nvar MismatchedTag =\n/*#__PURE__*/\nfunction () {\n  function MismatchedTag() {\n    _classCallCheck(this, MismatchedTag);\n\n    this._openTagStack = [];\n    this._mismatchStacksByOpenName = new Map();\n    this._closeTagMisplacements = [];\n    this._unopenedTags = [];\n  }\n\n  _createClass(MismatchedTag, [{\n    key: \"openTag\",\n    value: function openTag(location, _ref) {\n      var name = _ref.name;\n\n      this._openTagStack.push({\n        location: location,\n        name: name\n      });\n    }\n  }, {\n    key: \"closeTag\",\n    value: function closeTag(location, name) {\n      var openIndex = findLastIndex(this._openTagStack, function (openTag) {\n        return openTag.name === name;\n      });\n      var isOpened = openIndex >= 0;\n\n      if (isOpened) {\n        for (var i = openIndex + 1; i < this._openTagStack.length; ++i) {\n          var openTag = this._openTagStack[i];\n          var mismatch = {\n            openTag: openTag,\n            closeTag: {\n              location: location,\n              name: name\n            }\n          };\n\n          var mismatches = this._mismatchStacksByOpenName.get(openTag.name);\n\n          if (mismatches) {\n            mismatches.push(mismatch);\n          } else {\n            this._mismatchStacksByOpenName.set(openTag.name, [mismatch]);\n          }\n        }\n\n        this._openTagStack.splice(openIndex);\n      } else {\n        var mismatchStack = this._mismatchStacksByOpenName.get(name) || [];\n        var matchingMismatch = mismatchStack.pop();\n\n        if (matchingMismatch) {\n          var _openTag = matchingMismatch.openTag,\n              closeTag = matchingMismatch.closeTag;\n\n          this._closeTagMisplacements.push({\n            match: location,\n            openTag: _openTag,\n            closeTag: closeTag\n          });\n        } else {\n          this._unopenedTags.push({\n            location: location,\n            name: name\n          });\n        }\n      }\n    }\n  }, {\n    key: \"done\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function done() {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, mismatches, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _step4$value, openTag, closeTag, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, match, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3;\n\n      return regeneratorRuntime.wrap(function done$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 3;\n              _iterator = this._mismatchStacksByOpenName.values()[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 36;\n                break;\n              }\n\n              mismatches = _step.value;\n              _iteratorNormalCompletion4 = true;\n              _didIteratorError4 = false;\n              _iteratorError4 = undefined;\n              _context.prev = 10;\n              _iterator4 = mismatches[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                _context.next = 19;\n                break;\n              }\n\n              _step4$value = _step4.value, openTag = _step4$value.openTag, closeTag = _step4$value.closeTag;\n              _context.next = 16;\n              return {\n                code: Code.UNCLOSED_TAG,\n                openTag: openTag,\n                closeTag: closeTag\n              };\n\n            case 16:\n              _iteratorNormalCompletion4 = true;\n              _context.next = 12;\n              break;\n\n            case 19:\n              _context.next = 25;\n              break;\n\n            case 21:\n              _context.prev = 21;\n              _context.t0 = _context[\"catch\"](10);\n              _didIteratorError4 = true;\n              _iteratorError4 = _context.t0;\n\n            case 25:\n              _context.prev = 25;\n              _context.prev = 26;\n\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n\n            case 28:\n              _context.prev = 28;\n\n              if (!_didIteratorError4) {\n                _context.next = 31;\n                break;\n              }\n\n              throw _iteratorError4;\n\n            case 31:\n              return _context.finish(28);\n\n            case 32:\n              return _context.finish(25);\n\n            case 33:\n              _iteratorNormalCompletion = true;\n              _context.next = 5;\n              break;\n\n            case 36:\n              _context.next = 42;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t1 = _context[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 42:\n              _context.prev = 42;\n              _context.prev = 43;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 45:\n              _context.prev = 45;\n\n              if (!_didIteratorError) {\n                _context.next = 48;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 48:\n              return _context.finish(45);\n\n            case 49:\n              return _context.finish(42);\n\n            case 50:\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 53;\n              _iterator2 = this._closeTagMisplacements[Symbol.iterator]();\n\n            case 55:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 62;\n                break;\n              }\n\n              _step2$value = _step2.value, openTag = _step2$value.openTag, closeTag = _step2$value.closeTag, match = _step2$value.match;\n              _context.next = 59;\n              return {\n                code: Code.MISPLACED_CLOSE_TAG,\n                openTag: openTag,\n                closeTag: closeTag,\n                match: match\n              };\n\n            case 59:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 55;\n              break;\n\n            case 62:\n              _context.next = 68;\n              break;\n\n            case 64:\n              _context.prev = 64;\n              _context.t2 = _context[\"catch\"](53);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t2;\n\n            case 68:\n              _context.prev = 68;\n              _context.prev = 69;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 71:\n              _context.prev = 71;\n\n              if (!_didIteratorError2) {\n                _context.next = 74;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 74:\n              return _context.finish(71);\n\n            case 75:\n              return _context.finish(68);\n\n            case 76:\n              _iteratorNormalCompletion3 = true;\n              _didIteratorError3 = false;\n              _iteratorError3 = undefined;\n              _context.prev = 79;\n              _iterator3 = this._unopenedTags[Symbol.iterator]();\n\n            case 81:\n              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                _context.next = 88;\n                break;\n              }\n\n              closeTag = _step3.value;\n              _context.next = 85;\n              return {\n                code: Code.UNOPENED_TAG,\n                closeTag: closeTag\n              };\n\n            case 85:\n              _iteratorNormalCompletion3 = true;\n              _context.next = 81;\n              break;\n\n            case 88:\n              _context.next = 94;\n              break;\n\n            case 90:\n              _context.prev = 90;\n              _context.t3 = _context[\"catch\"](79);\n              _didIteratorError3 = true;\n              _iteratorError3 = _context.t3;\n\n            case 94:\n              _context.prev = 94;\n              _context.prev = 95;\n\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n\n            case 97:\n              _context.prev = 97;\n\n              if (!_didIteratorError3) {\n                _context.next = 100;\n                break;\n              }\n\n              throw _iteratorError3;\n\n            case 100:\n              return _context.finish(97);\n\n            case 101:\n              return _context.finish(94);\n\n            case 102:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, done, this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49], [53, 64, 68, 76], [69,, 71, 75], [79, 90, 94, 102], [95,, 97, 101]]);\n    })\n  }]);\n\n  return MismatchedTag;\n}();\n\nexport { MismatchedTag as default };",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/src/validations/html/rules/MismatchedTag.js"
    ],
    "names": [
      "findLastIndex",
      "Code",
      "MismatchedTag",
      "_openTagStack",
      "_mismatchStacksByOpenName",
      "Map",
      "_closeTagMisplacements",
      "_unopenedTags",
      "location",
      "name",
      "push",
      "openIndex",
      "openTag",
      "isOpened",
      "i",
      "length",
      "mismatch",
      "closeTag",
      "mismatches",
      "get",
      "set",
      "splice",
      "mismatchStack",
      "matchingMismatch",
      "pop",
      "match",
      "values",
      "code",
      "UNCLOSED_TAG",
      "MISPLACED_CLOSE_TAG",
      "UNOPENED_TAG"
    ],
    "mappings": ";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,aAAP,MAA0B,yBAA1B;AAEA,OAAOC,IAAP,MAAiB,QAAjB;;IAEqBC,a;;;AACnB,2BAAc;AAAA;;AACZ,SAAKC,aAAL,GAAqB,EAArB;AACA,SAAKC,yBAAL,GAAiC,IAAIC,GAAJ,EAAjC;AACA,SAAKC,sBAAL,GAA8B,EAA9B;AACA,SAAKC,aAAL,GAAqB,EAArB;AACD;;;;4BAEOC,Q,QAAkB;AAAA,UAAPC,IAAO,QAAPA,IAAO;;AACxB,WAAKN,aAAL,CAAmBO,IAAnB,CAAwB;AAACF,QAAAA,QAAQ,EAARA,QAAD;AAAWC,QAAAA,IAAI,EAAJA;AAAX,OAAxB;AACD;;;6BAEQD,Q,EAAUC,I,EAAM;AACvB,UAAME,SAAS,GAAGX,aAAa,CAC7B,KAAKG,aADwB,EAE7B,UAAAS,OAAO;AAAA,eAAIA,OAAO,CAACH,IAAR,KAAiBA,IAArB;AAAA,OAFsB,CAA/B;AAKA,UAAMI,QAAQ,GAAGF,SAAS,IAAI,CAA9B;;AACA,UAAIE,QAAJ,EAAc;AACZ,aAAK,IAAIC,CAAC,GAAGH,SAAS,GAAG,CAAzB,EAA4BG,CAAC,GAAG,KAAKX,aAAL,CAAmBY,MAAnD,EAA2D,EAAED,CAA7D,EAAgE;AAC9D,cAAMF,OAAO,GAAG,KAAKT,aAAL,CAAmBW,CAAnB,CAAhB;AACA,cAAME,QAAQ,GAAG;AACfJ,YAAAA,OAAO,EAAPA,OADe;AAEfK,YAAAA,QAAQ,EAAE;AAACT,cAAAA,QAAQ,EAARA,QAAD;AAAWC,cAAAA,IAAI,EAAJA;AAAX;AAFK,WAAjB;;AAIA,cAAMS,UAAU,GAAG,KAAKd,yBAAL,CAA+Be,GAA/B,CAAmCP,OAAO,CAACH,IAA3C,CAAnB;;AACA,cAAIS,UAAJ,EAAgB;AACdA,YAAAA,UAAU,CAACR,IAAX,CAAgBM,QAAhB;AACD,WAFD,MAEO;AACL,iBAAKZ,yBAAL,CAA+BgB,GAA/B,CAAmCR,OAAO,CAACH,IAA3C,EAAiD,CAACO,QAAD,CAAjD;AACD;AACF;;AACD,aAAKb,aAAL,CAAmBkB,MAAnB,CAA0BV,SAA1B;AACD,OAfD,MAeO;AACL,YAAMW,aAAa,GAAG,KAAKlB,yBAAL,CAA+Be,GAA/B,CAAmCV,IAAnC,KAA4C,EAAlE;AACA,YAAMc,gBAAgB,GAAGD,aAAa,CAACE,GAAd,EAAzB;;AACA,YAAID,gBAAJ,EAAsB;AAAA,cACbX,QADa,GACQW,gBADR,CACbX,OADa;AAAA,cACJK,QADI,GACQM,gBADR,CACJN,QADI;;AAEpB,eAAKX,sBAAL,CAA4BI,IAA5B,CAAiC;AAACe,YAAAA,KAAK,EAAEjB,QAAR;AAAkBI,YAAAA,OAAO,EAAPA,QAAlB;AAA2BK,YAAAA,QAAQ,EAARA;AAA3B,WAAjC;AACD,SAHD,MAGO;AACL,eAAKV,aAAL,CAAmBG,IAAnB,CAAwB;AAACF,YAAAA,QAAQ,EAARA,QAAD;AAAWC,YAAAA,IAAI,EAAJA;AAAX,WAAxB;AACD;AACF;AACF;;;;;;;;;;;;;;;;0BAG0B,KAAKL,yBAAL,CAA+BsB,MAA/B,E;;;;;;;;AAAdR,cAAAA,U;;;;;2BACyBA,U;;;;;;;;2CAAtBN,O,gBAAAA,O,EAASK,Q,gBAAAA,Q;;AACnB,qBAAM;AAACU,gBAAAA,IAAI,EAAE1B,IAAI,CAAC2B,YAAZ;AAA0BhB,gBAAAA,OAAO,EAAPA,OAA1B;AAAmCK,gBAAAA,QAAQ,EAARA;AAAnC,eAAN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAIqC,KAAKX,sB;;;;;;;;2CAAlCM,O,gBAAAA,O,EAASK,Q,gBAAAA,Q,EAAUQ,K,gBAAAA,K;;AAC7B,qBAAM;AAACE,gBAAAA,IAAI,EAAE1B,IAAI,CAAC4B,mBAAZ;AAAiCjB,gBAAAA,OAAO,EAAPA,OAAjC;AAA0CK,gBAAAA,QAAQ,EAARA,QAA1C;AAAoDQ,gBAAAA,KAAK,EAALA;AAApD,eAAN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAGqB,KAAKlB,a;;;;;;;;AAAjBU,cAAAA,Q;;AACT,qBAAM;AAACU,gBAAAA,IAAI,EAAE1B,IAAI,CAAC6B,YAAZ;AAA0Bb,gBAAAA,QAAQ,EAARA;AAA1B,eAAN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA1Def,a",
    "sourcesContent": [
      "// If any spare unopened tag exists afterward, diagnose it and only yield\n// MISPLACED_CLOSE_TAG.\n//\n// Otherwise:\n//\n// A mismatched close tag that has been opened means the case\n//\n// <div>\n//   <span>\n// </div>\n//\n// so yield UNCLOSED_TAG.\n//\n// A mismatched close tag that has yet to be opened means the case\n//\n// <div>\n//   </span>\n// </div>\n//\n// so yield UNOPENED_TAG.\n\nimport findLastIndex from 'lodash-es/findLastIndex';\n\nimport Code from './Code';\n\nexport default class MismatchedTag {\n  constructor() {\n    this._openTagStack = [];\n    this._mismatchStacksByOpenName = new Map();\n    this._closeTagMisplacements = [];\n    this._unopenedTags = [];\n  }\n\n  openTag(location, {name}) {\n    this._openTagStack.push({location, name});\n  }\n\n  closeTag(location, name) {\n    const openIndex = findLastIndex(\n      this._openTagStack,\n      openTag => openTag.name === name,\n    );\n\n    const isOpened = openIndex >= 0;\n    if (isOpened) {\n      for (let i = openIndex + 1; i < this._openTagStack.length; ++i) {\n        const openTag = this._openTagStack[i];\n        const mismatch = {\n          openTag,\n          closeTag: {location, name},\n        };\n        const mismatches = this._mismatchStacksByOpenName.get(openTag.name);\n        if (mismatches) {\n          mismatches.push(mismatch);\n        } else {\n          this._mismatchStacksByOpenName.set(openTag.name, [mismatch]);\n        }\n      }\n      this._openTagStack.splice(openIndex);\n    } else {\n      const mismatchStack = this._mismatchStacksByOpenName.get(name) || [];\n      const matchingMismatch = mismatchStack.pop();\n      if (matchingMismatch) {\n        const {openTag, closeTag} = matchingMismatch;\n        this._closeTagMisplacements.push({match: location, openTag, closeTag});\n      } else {\n        this._unopenedTags.push({location, name});\n      }\n    }\n  }\n\n  *done() {\n    for (const mismatches of this._mismatchStacksByOpenName.values()) {\n      for (const {openTag, closeTag} of mismatches) {\n        yield {code: Code.UNCLOSED_TAG, openTag, closeTag};\n      }\n    }\n\n    for (const {openTag, closeTag, match} of this._closeTagMisplacements) {\n      yield {code: Code.MISPLACED_CLOSE_TAG, openTag, closeTag, match};\n    }\n\n    for (const closeTag of this._unopenedTags) {\n      yield {code: Code.UNOPENED_TAG, closeTag};\n    }\n  }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

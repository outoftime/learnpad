{
  "ast": null,
  "code": "/*\n    \n*/\nvar ParsedComponents = require('../../result').ParsedComponents;\n\nvar Refiner = require('../refiner').Refiner;\n\nvar mergeDateTimeComponent = require('../en/ENMergeDateTimeRefiner').mergeDateTimeComponent;\n\nvar isDateOnly = require('../en/ENMergeDateTimeRefiner').isDateOnly;\n\nvar isTimeOnly = require('../en/ENMergeDateTimeRefiner').isTimeOnly;\n\nvar PATTERN = new RegExp(\"^\\\\s*(T|um|am|,|-)?\\\\s*$\");\n\nfunction isAbleToMerge(text, prevResult, curResult) {\n  var textBetween = text.substring(prevResult.index + prevResult.text.length, curResult.index);\n  return textBetween.match(PATTERN);\n}\n\nfunction mergeResult(text, dateResult, timeResult) {\n  var beginDate = dateResult.start;\n  var beginTime = timeResult.start;\n  var beginDateTime = mergeDateTimeComponent(beginDate, beginTime);\n\n  if (dateResult.end != null || timeResult.end != null) {\n    var endDate = dateResult.end == null ? dateResult.start : dateResult.end;\n    var endTime = timeResult.end == null ? timeResult.start : timeResult.end;\n    var endDateTime = mergeDateTimeComponent(endDate, endTime);\n\n    if (dateResult.end == null && endDateTime.date().getTime() < beginDateTime.date().getTime()) {\n      // Ex. 9pm - 1am\n      if (endDateTime.isCertain('day')) {\n        endDateTime.assign('day', endDateTime.get('day') + 1);\n      } else {\n        endDateTime.imply('day', endDateTime.get('day') + 1);\n      }\n    }\n\n    dateResult.end = endDateTime;\n  }\n\n  dateResult.start = beginDateTime;\n  var startIndex = Math.min(dateResult.index, timeResult.index);\n  var endIndex = Math.max(dateResult.index + dateResult.text.length, timeResult.index + timeResult.text.length);\n  dateResult.index = startIndex;\n  dateResult.text = text.substring(startIndex, endIndex);\n\n  for (var tag in timeResult.tags) {\n    dateResult.tags[tag] = true;\n  }\n\n  dateResult.tags['DEMergeDateAndTimeRefiner'] = true;\n  return dateResult;\n}\n\nexports.Refiner = function DEMergeDateTimeRefiner() {\n  Refiner.call(this);\n\n  this.refine = function (text, results, opt) {\n    if (results.length < 2) return results;\n    var mergedResult = [];\n    var currResult = null;\n    var prevResult = null;\n\n    for (var i = 1; i < results.length; i++) {\n      currResult = results[i];\n      prevResult = results[i - 1];\n\n      if (isDateOnly(prevResult) && isTimeOnly(currResult) && isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = mergeResult(text, prevResult, currResult);\n        currResult = null;\n        i += 1;\n      } else if (isDateOnly(currResult) && isTimeOnly(prevResult) && isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = mergeResult(text, currResult, prevResult);\n        currResult = null;\n        i += 1;\n      }\n\n      mergedResult.push(prevResult);\n    }\n\n    if (currResult != null) {\n      mergedResult.push(currResult);\n    }\n\n    return mergedResult;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/refiners/de/DEMergeDateTimeRefiner.js"
    ],
    "names": [
      "ParsedComponents",
      "require",
      "Refiner",
      "mergeDateTimeComponent",
      "isDateOnly",
      "isTimeOnly",
      "PATTERN",
      "RegExp",
      "isAbleToMerge",
      "text",
      "prevResult",
      "curResult",
      "textBetween",
      "substring",
      "index",
      "length",
      "match",
      "mergeResult",
      "dateResult",
      "timeResult",
      "beginDate",
      "start",
      "beginTime",
      "beginDateTime",
      "end",
      "endDate",
      "endTime",
      "endDateTime",
      "date",
      "getTime",
      "isCertain",
      "assign",
      "get",
      "imply",
      "startIndex",
      "Math",
      "min",
      "endIndex",
      "max",
      "tag",
      "tags",
      "exports",
      "DEMergeDateTimeRefiner",
      "call",
      "refine",
      "results",
      "opt",
      "mergedResult",
      "currResult",
      "i",
      "push"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n    \n*/\nvar ParsedComponents = require('../../result').ParsedComponents;\nvar Refiner = require('../refiner').Refiner;\n\nvar mergeDateTimeComponent = require('../en/ENMergeDateTimeRefiner').mergeDateTimeComponent;\nvar isDateOnly = require('../en/ENMergeDateTimeRefiner').isDateOnly;\nvar isTimeOnly = require('../en/ENMergeDateTimeRefiner').isTimeOnly;\n\nvar PATTERN = new RegExp(\"^\\\\s*(T|um|am|,|-)?\\\\s*$\");\n\nfunction isAbleToMerge(text, prevResult, curResult) {\n    var textBetween = text.substring(prevResult.index + prevResult.text.length, curResult.index);\n    return textBetween.match(PATTERN);\n}\n\nfunction mergeResult(text, dateResult, timeResult){\n\n    var beginDate = dateResult.start;\n    var beginTime = timeResult.start;    \n    var beginDateTime = mergeDateTimeComponent(beginDate, beginTime);\n\n    if (dateResult.end != null || timeResult.end != null) {\n        \n        var endDate   = dateResult.end == null ? dateResult.start : dateResult.end;            \n        var endTime   = timeResult.end == null ? timeResult.start : timeResult.end;\n        var endDateTime = mergeDateTimeComponent(endDate, endTime);\n        \n        if (dateResult.end == null && endDateTime.date().getTime() < beginDateTime.date().getTime()) {\n            // Ex. 9pm - 1am\n            if (endDateTime.isCertain('day')) {\n                endDateTime.assign('day', endDateTime.get('day') + 1);\n            } else {\n                endDateTime.imply('day', endDateTime.get('day') + 1);\n            }\n        }\n\n        dateResult.end = endDateTime;\n    }\n\n    dateResult.start = beginDateTime;    \n\n    var startIndex = Math.min(dateResult.index, timeResult.index);\n    var endIndex = Math.max(\n            dateResult.index + dateResult.text.length, \n            timeResult.index + timeResult.text.length);\n    \n    dateResult.index = startIndex;\n    dateResult.text  = text.substring(startIndex, endIndex);\n\n    for (var tag in timeResult.tags) {\n        dateResult.tags[tag] = true;\n    }\n    dateResult.tags['DEMergeDateAndTimeRefiner'] = true;\n    return dateResult;\n}\n\nexports.Refiner = function DEMergeDateTimeRefiner() {\n    Refiner.call(this);\n\n\n    this.refine = function(text, results, opt) { \n\n        if (results.length < 2) return results;\n\n        var mergedResult = [];\n        var currResult = null;\n        var prevResult = null;\n\n        for (var i = 1; i < results.length; i++) {\n\n            currResult = results[i];\n            prevResult = results[i-1];\n            \n            if (isDateOnly(prevResult) && isTimeOnly(currResult) \n                    && isAbleToMerge(text, prevResult, currResult)) {\n                \n                prevResult = mergeResult(text, prevResult, currResult);\n                currResult = null;\n                i += 1;\n                \n            } else if (isDateOnly(currResult) && isTimeOnly(prevResult)\n                    && isAbleToMerge(text, prevResult, currResult)) {\n                \n                prevResult = mergeResult(text, currResult, prevResult);\n                currResult = null;\n                i += 1;\n            }\n            \n            mergedResult.push(prevResult);\n        }\n\n        if (currResult != null) {\n            mergedResult.push(currResult);\n        }\n\n        return mergedResult;\n    }\n}"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

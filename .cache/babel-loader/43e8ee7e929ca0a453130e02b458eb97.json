{
  "ast": null,
  "code": "/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = new RegExp('(\\\\W|^)(' + 'jetzt|' + '(?:heute|diesen)\\\\s*(morgen|vormittag|mittag|nachmittag|abend)|' + '(?:heute|diese)\\\\s*nacht|' + 'heute|' + '(?:(?:端|ue)ber)?morgen(?:\\\\s*(morgen|vormittag|mittag|nachmittag|abend|nacht))?|' + '(?:vor)?gestern(?:\\\\s*(morgen|vormittag|mittag|nachmittag|abend|nacht))?|' + 'letzte\\\\s*nacht' + ')(?=\\\\W|$)', 'i');\n\nexports.Parser = function DECasualDateParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var text = match[0].substr(match[1].length);\n    var index = match.index + match[1].length;\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var refMoment = moment(ref);\n    var startMoment = refMoment.clone();\n    var lowerText = text.toLowerCase();\n\n    if (/(?:heute|diese)\\s*nacht/.test(lowerText)) {\n      // Normally means this coming midnight\n      result.start.imply('hour', 22);\n      result.start.imply('meridiem', 1);\n    } else if (/^(?:端|ue)bermorgen/.test(lowerText)) {\n      startMoment.add(refMoment.hour() > 1 ? 2 : 1, 'day');\n    } else if (/^morgen/.test(lowerText)) {\n      // Check not \"Tomorrow\" on late night\n      if (refMoment.hour() > 1) {\n        startMoment.add(1, 'day');\n      }\n    } else if (/^gestern/.test(lowerText)) {\n      startMoment.add(-1, 'day');\n    } else if (/^vorgestern/.test(lowerText)) {\n      startMoment.add(-2, 'day');\n    } else if (/letzte\\s*nacht/.test(lowerText)) {\n      result.start.imply('hour', 0);\n\n      if (refMoment.hour() > 6) {\n        startMoment.add(-1, 'day');\n      }\n    } else if (lowerText === 'jetzt') {\n      result.start.imply('hour', refMoment.hour());\n      result.start.imply('minute', refMoment.minute());\n      result.start.imply('second', refMoment.second());\n      result.start.imply('millisecond', refMoment.millisecond());\n    }\n\n    var secondMatch = match[3] || match[4] || match[5];\n\n    if (secondMatch) {\n      switch (secondMatch.toLowerCase()) {\n        case 'morgen':\n          result.start.imply('hour', 6);\n          break;\n\n        case 'vormittag':\n          result.start.imply('hour', 9);\n          break;\n\n        case 'mittag':\n          result.start.imply('hour', 12);\n          break;\n\n        case 'nachmittag':\n          result.start.imply('hour', 15);\n          result.start.imply('meridiem', 1);\n          break;\n\n        case 'abend':\n          result.start.imply('hour', 18);\n          result.start.imply('meridiem', 1);\n          break;\n\n        case 'nacht':\n          result.start.imply('hour', 0);\n          break;\n      }\n    }\n\n    result.start.assign('day', startMoment.date());\n    result.start.assign('month', startMoment.month() + 1);\n    result.start.assign('year', startMoment.year());\n    result.tags['DECasualDateParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/de/DECasualDateParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "PATTERN",
      "RegExp",
      "exports",
      "DECasualDateParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "substr",
      "length",
      "index",
      "result",
      "refMoment",
      "startMoment",
      "clone",
      "lowerText",
      "toLowerCase",
      "test",
      "start",
      "imply",
      "add",
      "hour",
      "minute",
      "second",
      "millisecond",
      "secondMatch",
      "assign",
      "date",
      "month",
      "year",
      "tags"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n\n\n*/\n\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = new RegExp(\n    '(\\\\W|^)(' +\n        'jetzt|' +\n        '(?:heute|diesen)\\\\s*(morgen|vormittag|mittag|nachmittag|abend)|' +\n        '(?:heute|diese)\\\\s*nacht|' +\n        'heute|' +\n        '(?:(?:端|ue)ber)?morgen(?:\\\\s*(morgen|vormittag|mittag|nachmittag|abend|nacht))?|' +\n        '(?:vor)?gestern(?:\\\\s*(morgen|vormittag|mittag|nachmittag|abend|nacht))?|' +\n        'letzte\\\\s*nacht' +\n    ')(?=\\\\W|$)', 'i');\n\nexports.Parser = function DECasualDateParser() {\n\n    Parser.apply(this, arguments);\n\n    this.pattern = function() { return PATTERN; }\n\n    this.extract = function(text, ref, match, opt) {\n        var text = match[0].substr(match[1].length);\n        var index = match.index + match[1].length;\n        var result = new ParsedResult({\n            index: index,\n            text: text,\n            ref: ref,\n        });\n\n        var refMoment = moment(ref);\n        var startMoment = refMoment.clone();\n        var lowerText = text.toLowerCase();\n\n        if (/(?:heute|diese)\\s*nacht/.test(lowerText)) {\n            // Normally means this coming midnight\n            result.start.imply('hour', 22);\n            result.start.imply('meridiem', 1);\n        } else if (/^(?:端|ue)bermorgen/.test(lowerText)) {\n            startMoment.add(refMoment.hour() > 1 ? 2 : 1, 'day');\n        } else if (/^morgen/.test(lowerText)) {\n            // Check not \"Tomorrow\" on late night\n            if (refMoment.hour() > 1) {\n                startMoment.add(1, 'day');\n            }\n        } else if (/^gestern/.test(lowerText)) {\n            startMoment.add(-1, 'day');\n        } else if (/^vorgestern/.test(lowerText)) {\n            startMoment.add(-2, 'day');\n        } else if (/letzte\\s*nacht/.test(lowerText)) {\n            result.start.imply('hour', 0);\n            if (refMoment.hour() > 6) {\n                startMoment.add(-1, 'day');\n            }\n        } else if (lowerText === 'jetzt') {\n          result.start.imply('hour', refMoment.hour());\n          result.start.imply('minute', refMoment.minute());\n          result.start.imply('second', refMoment.second());\n          result.start.imply('millisecond', refMoment.millisecond());\n        }\n\n        var secondMatch = match[3] || match[4] || match[5];\n        if (secondMatch) {\n            switch (secondMatch.toLowerCase()) {\n                case 'morgen':\n                    result.start.imply('hour', 6);\n                    break;\n                case 'vormittag':\n                    result.start.imply('hour', 9);\n                    break;\n                case 'mittag':\n                    result.start.imply('hour', 12);\n                    break;\n                case 'nachmittag':\n                    result.start.imply('hour', 15);\n                    result.start.imply('meridiem', 1);\n                    break;\n                case 'abend':\n                    result.start.imply('hour', 18);\n                    result.start.imply('meridiem', 1);\n                    break;\n                case 'nacht':\n                    result.start.imply('hour', 0);\n                    break;\n            }\n        }\n\n        result.start.assign('day', startMoment.date())\n        result.start.assign('month', startMoment.month() + 1)\n        result.start.assign('year', startMoment.year())\n        result.tags['DECasualDateParser'] = true;\n        return result;\n    }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

{
  "ast": null,
  "code": "import SAXParser from 'parse5-sax-parser';\nimport voidElements from 'void-elements'; // Runs `rules` on `source` and promises an iterable of all errors.\n//\n// `rules` must be an array of objects that satisfy the interface:\n// * done() returns an iterable of errors\n// * optionally,\n//   openTag({row: number, column: number}, {name: string})\n//   to take in open tags that are neither void nor self-closing\n// * optionally,\n//   closeTag({row: number, column: number}, name: string)\n//   to take in close tags\n\nexport default (function (rules, source) {\n  var parser = new SAXParser({\n    sourceCodeLocationInfo: true\n  });\n  return new Promise(function (resolve) {\n    parser.on('startTag', function (_ref) {\n      var tagName = _ref.tagName,\n          selfClosing = _ref.selfClosing,\n          _ref$sourceCodeLocati = _ref.sourceCodeLocation,\n          startLine = _ref$sourceCodeLocati.startLine,\n          startCol = _ref$sourceCodeLocati.startCol;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var rule = _step.value;\n\n          if (rule.openTag && !selfClosing && !(tagName in voidElements)) {\n            rule.openTag({\n              row: startLine - 1,\n              column: startCol - 1\n            }, {\n              name: tagName\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n    parser.on('endTag', function (_ref2) {\n      var tagName = _ref2.tagName,\n          _ref2$sourceCodeLocat = _ref2.sourceCodeLocation,\n          startLine = _ref2$sourceCodeLocat.startLine,\n          startCol = _ref2$sourceCodeLocat.startCol;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var rule = _step2.value;\n\n          if (rule.closeTag) {\n            rule.closeTag({\n              row: startLine - 1,\n              column: startCol - 1\n            }, tagName);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n    parser.on('text', function (_ref3) {\n      var text = _ref3.text,\n          _ref3$sourceCodeLocat = _ref3.sourceCodeLocation,\n          startLine = _ref3$sourceCodeLocat.startLine,\n          startCol = _ref3$sourceCodeLocat.startCol;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var rule = _step3.value;\n\n          if (rule.text) {\n            rule.text({\n              row: startLine - 1,\n              column: startCol - 1\n            }, text);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    });\n    parser.write(source);\n    parser.end(function () {\n      resolve(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function getRules() {\n        var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, rule;\n\n        return regeneratorRuntime.wrap(function getRules$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _iteratorNormalCompletion4 = true;\n                _didIteratorError4 = false;\n                _iteratorError4 = undefined;\n                _context.prev = 3;\n                _iterator4 = rules[Symbol.iterator]();\n\n              case 5:\n                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                  _context.next = 11;\n                  break;\n                }\n\n                rule = _step4.value;\n                return _context.delegateYield(rule.done(), \"t0\", 8);\n\n              case 8:\n                _iteratorNormalCompletion4 = true;\n                _context.next = 5;\n                break;\n\n              case 11:\n                _context.next = 17;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t1 = _context[\"catch\"](3);\n                _didIteratorError4 = true;\n                _iteratorError4 = _context.t1;\n\n              case 17:\n                _context.prev = 17;\n                _context.prev = 18;\n\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  _iterator4.return();\n                }\n\n              case 20:\n                _context.prev = 20;\n\n                if (!_didIteratorError4) {\n                  _context.next = 23;\n                  break;\n                }\n\n                throw _iteratorError4;\n\n              case 23:\n                return _context.finish(20);\n\n              case 24:\n                return _context.finish(17);\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, getRules, null, [[3, 13, 17, 25], [18,, 20, 24]]);\n      })());\n    });\n  });\n});",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/src/validations/html/runRules.js"
    ],
    "names": [
      "SAXParser",
      "voidElements",
      "rules",
      "source",
      "parser",
      "sourceCodeLocationInfo",
      "Promise",
      "resolve",
      "on",
      "tagName",
      "selfClosing",
      "sourceCodeLocation",
      "startLine",
      "startCol",
      "rule",
      "openTag",
      "row",
      "column",
      "name",
      "closeTag",
      "text",
      "write",
      "end",
      "getRules",
      "done"
    ],
    "mappings": "AAAA,OAAOA,SAAP,MAAsB,mBAAtB;AACA,OAAOC,YAAP,MAAyB,eAAzB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAe,UAACC,KAAD,EAAQC,MAAR,EAAmB;AAChC,MAAMC,MAAM,GAAG,IAAIJ,SAAJ,CAAc;AAACK,IAAAA,sBAAsB,EAAE;AAAzB,GAAd,CAAf;AACA,SAAO,IAAIC,OAAJ,CAAY,UAAAC,OAAO,EAAI;AAC5BH,IAAAA,MAAM,CAACI,EAAP,CACE,UADF,EAEE,gBAAuE;AAAA,UAArEC,OAAqE,QAArEA,OAAqE;AAAA,UAA5DC,WAA4D,QAA5DA,WAA4D;AAAA,uCAA/CC,kBAA+C;AAAA,UAA1BC,SAA0B,yBAA1BA,SAA0B;AAAA,UAAfC,QAAe,yBAAfA,QAAe;AAAA;AAAA;AAAA;;AAAA;AACrE,6BAAmBX,KAAnB,8HAA0B;AAAA,cAAfY,IAAe;;AACxB,cAAIA,IAAI,CAACC,OAAL,IAAgB,CAACL,WAAjB,IAAgC,EAAED,OAAO,IAAIR,YAAb,CAApC,EAAgE;AAC9Da,YAAAA,IAAI,CAACC,OAAL,CACE;AAACC,cAAAA,GAAG,EAAEJ,SAAS,GAAG,CAAlB;AAAqBK,cAAAA,MAAM,EAAEJ,QAAQ,GAAG;AAAxC,aADF,EAEE;AAACK,cAAAA,IAAI,EAAET;AAAP,aAFF;AAID;AACF;AARoE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAStE,KAXH;AAaAL,IAAAA,MAAM,CAACI,EAAP,CACE,QADF,EAEE,iBAA0D;AAAA,UAAxDC,OAAwD,SAAxDA,OAAwD;AAAA,wCAA/CE,kBAA+C;AAAA,UAA1BC,SAA0B,yBAA1BA,SAA0B;AAAA,UAAfC,QAAe,yBAAfA,QAAe;AAAA;AAAA;AAAA;;AAAA;AACxD,8BAAmBX,KAAnB,mIAA0B;AAAA,cAAfY,IAAe;;AACxB,cAAIA,IAAI,CAACK,QAAT,EAAmB;AACjBL,YAAAA,IAAI,CAACK,QAAL,CAAc;AAACH,cAAAA,GAAG,EAAEJ,SAAS,GAAG,CAAlB;AAAqBK,cAAAA,MAAM,EAAEJ,QAAQ,GAAG;AAAxC,aAAd,EAA0DJ,OAA1D;AACD;AACF;AALuD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMzD,KARH;AAUAL,IAAAA,MAAM,CAACI,EAAP,CAAU,MAAV,EAAkB,iBAAuD;AAAA,UAArDY,IAAqD,SAArDA,IAAqD;AAAA,wCAA/CT,kBAA+C;AAAA,UAA1BC,SAA0B,yBAA1BA,SAA0B;AAAA,UAAfC,QAAe,yBAAfA,QAAe;AAAA;AAAA;AAAA;;AAAA;AACvE,8BAAmBX,KAAnB,mIAA0B;AAAA,cAAfY,IAAe;;AACxB,cAAIA,IAAI,CAACM,IAAT,EAAe;AACbN,YAAAA,IAAI,CAACM,IAAL,CAAU;AAACJ,cAAAA,GAAG,EAAEJ,SAAS,GAAG,CAAlB;AAAqBK,cAAAA,MAAM,EAAEJ,QAAQ,GAAG;AAAxC,aAAV,EAAsDO,IAAtD;AACD;AACF;AALsE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMxE,KAND;AAOAhB,IAAAA,MAAM,CAACiB,KAAP,CAAalB,MAAb;AACAC,IAAAA,MAAM,CAACkB,GAAP,CAAW,YAAM;AACff,MAAAA,OAAO;AACL;AAAA,8BAAC,SAAUgB,QAAV;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BACoBrB,KADpB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACYY,gBAAAA,IADZ;AAEG,8CAAOA,IAAI,CAACU,IAAL,EAAP;;AAFH;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAUD,QAAV;AAAA,OAAD,GADK,CAAP;AAOD,KARD;AASD,GAzCM,CAAP;AA0CD,CA5CD",
    "sourcesContent": [
      "import SAXParser from 'parse5-sax-parser';\nimport voidElements from 'void-elements';\n\n// Runs `rules` on `source` and promises an iterable of all errors.\n//\n// `rules` must be an array of objects that satisfy the interface:\n// * done() returns an iterable of errors\n// * optionally,\n//   openTag({row: number, column: number}, {name: string})\n//   to take in open tags that are neither void nor self-closing\n// * optionally,\n//   closeTag({row: number, column: number}, name: string)\n//   to take in close tags\nexport default (rules, source) => {\n  const parser = new SAXParser({sourceCodeLocationInfo: true});\n  return new Promise(resolve => {\n    parser.on(\n      'startTag',\n      ({tagName, selfClosing, sourceCodeLocation: {startLine, startCol}}) => {\n        for (const rule of rules) {\n          if (rule.openTag && !selfClosing && !(tagName in voidElements)) {\n            rule.openTag(\n              {row: startLine - 1, column: startCol - 1},\n              {name: tagName},\n            );\n          }\n        }\n      },\n    );\n    parser.on(\n      'endTag',\n      ({tagName, sourceCodeLocation: {startLine, startCol}}) => {\n        for (const rule of rules) {\n          if (rule.closeTag) {\n            rule.closeTag({row: startLine - 1, column: startCol - 1}, tagName);\n          }\n        }\n      },\n    );\n    parser.on('text', ({text, sourceCodeLocation: {startLine, startCol}}) => {\n      for (const rule of rules) {\n        if (rule.text) {\n          rule.text({row: startLine - 1, column: startCol - 1}, text);\n        }\n      }\n    });\n    parser.write(source);\n    parser.end(() => {\n      resolve(\n        (function* getRules() {\n          for (const rule of rules) {\n            yield* rule.done();\n          }\n        })(),\n      );\n    });\n  });\n};\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

{
  "ast": null,
  "code": "/*\n    \n    \n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;\n\nexports.Parser = function JPCasualDateParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var index = match.index;\n    var text = match[0];\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var refMoment = moment(ref);\n    var startMoment = refMoment.clone();\n\n    if (text == '今夜' || text == '今夕' || text == '今晩') {\n      // Normally means this coming midnight \n      result.start.imply('hour', 22);\n      result.start.imply('meridiem', 1);\n    } else if (text == '明日') {\n      // Check not \"Tomorrow\" on late night\n      if (refMoment.hour() > 4) {\n        startMoment.add(1, 'day');\n      }\n    } else if (text == '昨日') {\n      startMoment.add(-1, 'day');\n    } else if (text.match(\"今朝\")) {\n      result.start.imply('hour', 6);\n      result.start.imply('meridiem', 0);\n    }\n\n    result.start.assign('day', startMoment.date());\n    result.start.assign('month', startMoment.month() + 1);\n    result.start.assign('year', startMoment.year());\n    result.tags['JPCasualDateParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/ja/JPCasualDateParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "PATTERN",
      "exports",
      "JPCasualDateParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "index",
      "result",
      "refMoment",
      "startMoment",
      "clone",
      "start",
      "imply",
      "hour",
      "add",
      "assign",
      "date",
      "month",
      "year",
      "tags"
    ],
    "mappings": "AAAA;;;;AAKA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAP,CAAqBC,MAAlC;;AACA,IAAIC,YAAY,GAAGF,OAAO,CAAC,cAAD,CAAP,CAAwBE,YAA3C;;AAEA,IAAIC,OAAO,GAAG,0BAAd;;AAEAC,OAAO,CAACH,MAAR,GAAiB,SAASI,kBAAT,GAA6B;AAE1CJ,EAAAA,MAAM,CAACK,KAAP,CAAa,IAAb,EAAmBC,SAAnB;;AAEA,OAAKC,OAAL,GAAe,YAAW;AAAE,WAAOL,OAAP;AAAiB,GAA7C;;AAEA,OAAKM,OAAL,GAAe,UAASC,IAAT,EAAeC,GAAf,EAAoBC,KAApB,EAA2BC,GAA3B,EAA+B;AAE1C,QAAIC,KAAK,GAAGF,KAAK,CAACE,KAAlB;AACA,QAAIJ,IAAI,GAAGE,KAAK,CAAC,CAAD,CAAhB;AACA,QAAIG,MAAM,GAAG,IAAIb,YAAJ,CAAiB;AAC1BY,MAAAA,KAAK,EAAEA,KADmB;AAE1BJ,MAAAA,IAAI,EAAEA,IAFoB;AAG1BC,MAAAA,GAAG,EAAEA;AAHqB,KAAjB,CAAb;AAMA,QAAIK,SAAS,GAAGjB,MAAM,CAACY,GAAD,CAAtB;AACA,QAAIM,WAAW,GAAGD,SAAS,CAACE,KAAV,EAAlB;;AAEA,QAAGR,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IAAxB,IAAgCA,IAAI,IAAI,IAA3C,EAAgD;AAC5C;AACAK,MAAAA,MAAM,CAACI,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AACAL,MAAAA,MAAM,CAACI,KAAP,CAAaC,KAAb,CAAmB,UAAnB,EAA+B,CAA/B;AAEH,KALD,MAKO,IAAGV,IAAI,IAAI,IAAX,EAAgB;AAEnB;AACA,UAAGM,SAAS,CAACK,IAAV,KAAmB,CAAtB,EAAyB;AACrBJ,QAAAA,WAAW,CAACK,GAAZ,CAAgB,CAAhB,EAAmB,KAAnB;AACH;AAEJ,KAPM,MAOA,IAAGZ,IAAI,IAAI,IAAX,EAAiB;AAEpBO,MAAAA,WAAW,CAACK,GAAZ,CAAgB,CAAC,CAAjB,EAAoB,KAApB;AAEH,KAJM,MAIA,IAAIZ,IAAI,CAACE,KAAL,CAAW,IAAX,CAAJ,EAAsB;AAEzBG,MAAAA,MAAM,CAACI,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,CAA3B;AACAL,MAAAA,MAAM,CAACI,KAAP,CAAaC,KAAb,CAAmB,UAAnB,EAA+B,CAA/B;AACH;;AAEDL,IAAAA,MAAM,CAACI,KAAP,CAAaI,MAAb,CAAoB,KAApB,EAA2BN,WAAW,CAACO,IAAZ,EAA3B;AACAT,IAAAA,MAAM,CAACI,KAAP,CAAaI,MAAb,CAAoB,OAApB,EAA6BN,WAAW,CAACQ,KAAZ,KAAsB,CAAnD;AACAV,IAAAA,MAAM,CAACI,KAAP,CAAaI,MAAb,CAAoB,MAApB,EAA4BN,WAAW,CAACS,IAAZ,EAA5B;AACAX,IAAAA,MAAM,CAACY,IAAP,CAAY,oBAAZ,IAAoC,IAApC;AACA,WAAOZ,MAAP;AACH,GAxCD;AAyCH,CA/CD",
    "sourcesContent": [
      "/*\n    \n    \n*/\n\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;\n\nexports.Parser = function JPCasualDateParser(){\n    \n    Parser.apply(this, arguments);\n        \n    this.pattern = function() { return PATTERN; }\n    \n    this.extract = function(text, ref, match, opt){ \n        \n        var index = match.index;\n        var text = match[0];\n        var result = new ParsedResult({\n            index: index,\n            text: text,\n            ref: ref,\n        });\n\n        var refMoment = moment(ref);\n        var startMoment = refMoment.clone();\n\n        if(text == '今夜' || text == '今夕' || text == '今晩'){\n            // Normally means this coming midnight \n            result.start.imply('hour', 22);\n            result.start.imply('meridiem', 1);\n\n        } else if(text == '明日'){\n\n            // Check not \"Tomorrow\" on late night\n            if(refMoment.hour() > 4) {\n                startMoment.add(1, 'day');\n            }\n\n        } else if(text == '昨日') {\n\n            startMoment.add(-1, 'day');\n\n        } else if (text.match(\"今朝\")) {\n\n            result.start.imply('hour', 6);\n            result.start.imply('meridiem', 0);\n        }\n\n        result.start.assign('day', startMoment.date())\n        result.start.assign('month', startMoment.month() + 1)\n        result.start.assign('year', startMoment.year())\n        result.tags['JPCasualDateParser'] = true;\n        return result;\n    }\n}\n\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

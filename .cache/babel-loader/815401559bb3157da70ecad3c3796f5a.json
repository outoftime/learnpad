{
  "ast": null,
  "code": "/*\n  \n*/\nvar Refiner = require('../refiner').Refiner;\n\nexports.Refiner = function ENMergeDateRangeRefiner() {\n  Refiner.call(this);\n\n  this.pattern = function () {\n    return /^\\s*(to|\\-)\\s*$/i;\n  };\n\n  this.refine = function (text, results, opt) {\n    if (results.length < 2) return results;\n    var mergedResult = [];\n    var currResult = null;\n    var prevResult = null;\n\n    for (var i = 1; i < results.length; i++) {\n      currResult = results[i];\n      prevResult = results[i - 1];\n\n      if (!prevResult.end && !currResult.end && this.isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = this.mergeResult(text, prevResult, currResult);\n        currResult = null;\n        i += 1;\n      }\n\n      mergedResult.push(prevResult);\n    }\n\n    if (currResult != null) {\n      mergedResult.push(currResult);\n    }\n\n    return mergedResult;\n  };\n\n  this.isAbleToMerge = function (text, result1, result2) {\n    var begin = result1.index + result1.text.length;\n    var end = result2.index;\n    var textBetween = text.substring(begin, end);\n    return textBetween.match(this.pattern());\n  };\n\n  this.isWeekdayResult = function (result) {\n    return result.start.isCertain('weekday') && !result.start.isCertain('day');\n  };\n\n  this.mergeResult = function (text, fromResult, toResult) {\n    if (!this.isWeekdayResult(fromResult) && !this.isWeekdayResult(toResult)) {\n      var timeKeys = {\n        'hour': true,\n        'minute': true,\n        'second': true\n      };\n\n      for (var key in toResult.start.knownValues) {\n        if (!fromResult.start.isCertain(key)) {\n          fromResult.start.assign(key, toResult.start.get(key));\n        }\n      }\n\n      for (var key in fromResult.start.knownValues) {\n        if (!toResult.start.isCertain(key)) {\n          toResult.start.assign(key, fromResult.start.get(key));\n        }\n      }\n    }\n\n    if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {\n      var fromMoment = fromResult.start.moment();\n      var toMoment = toResult.start.moment();\n\n      if (this.isWeekdayResult(fromResult) && fromMoment.clone().add(-7, 'days').isBefore(toMoment)) {\n        fromMoment = fromMoment.add(-7, 'days');\n        fromResult.start.imply('day', fromMoment.date());\n        fromResult.start.imply('month', fromMoment.month() + 1);\n        fromResult.start.imply('year', fromMoment.year());\n      } else if (this.isWeekdayResult(toResult) && toMoment.clone().add(7, 'days').isAfter(fromMoment)) {\n        toMoment = toMoment.add(7, 'days');\n        toResult.start.imply('day', toMoment.date());\n        toResult.start.imply('month', toMoment.month() + 1);\n        toResult.start.imply('year', toMoment.year());\n      } else {\n        var tmp = toResult;\n        toResult = fromResult;\n        fromResult = tmp;\n      }\n    }\n\n    fromResult.end = toResult.start;\n\n    for (var tag in toResult.tags) {\n      fromResult.tags[tag] = true;\n    }\n\n    var startIndex = Math.min(fromResult.index, toResult.index);\n    var endIndex = Math.max(fromResult.index + fromResult.text.length, toResult.index + toResult.text.length);\n    fromResult.index = startIndex;\n    fromResult.text = text.substring(startIndex, endIndex);\n    fromResult.tags[this.constructor.name] = true;\n    return fromResult;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/refiners/en/ENMergeDateRangeRefiner.js"
    ],
    "names": [
      "Refiner",
      "require",
      "exports",
      "ENMergeDateRangeRefiner",
      "call",
      "pattern",
      "refine",
      "text",
      "results",
      "opt",
      "length",
      "mergedResult",
      "currResult",
      "prevResult",
      "i",
      "end",
      "isAbleToMerge",
      "mergeResult",
      "push",
      "result1",
      "result2",
      "begin",
      "index",
      "textBetween",
      "substring",
      "match",
      "isWeekdayResult",
      "result",
      "start",
      "isCertain",
      "fromResult",
      "toResult",
      "timeKeys",
      "key",
      "knownValues",
      "assign",
      "get",
      "date",
      "getTime",
      "fromMoment",
      "moment",
      "toMoment",
      "clone",
      "add",
      "isBefore",
      "imply",
      "month",
      "year",
      "isAfter",
      "tmp",
      "tag",
      "tags",
      "startIndex",
      "Math",
      "min",
      "endIndex",
      "max",
      "constructor",
      "name"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n  \n*/\nvar Refiner = require('../refiner').Refiner;\n\nexports.Refiner = function ENMergeDateRangeRefiner() {\n    Refiner.call(this);\n\n    this.pattern = function () { return /^\\s*(to|\\-)\\s*$/i };\n\n    this.refine = function(text, results, opt) {\n\n        if (results.length < 2) return results;\n        \n        var mergedResult = [];\n        var currResult = null;\n        var prevResult = null;\n        \n        for (var i=1; i<results.length; i++){\n            \n            currResult = results[i];\n            prevResult = results[i-1];\n            \n            if (!prevResult.end && !currResult.end \n                && this.isAbleToMerge(text, prevResult, currResult)) {\n              \n                prevResult = this.mergeResult(text, prevResult, currResult);\n                currResult = null;\n                i += 1;\n            }\n            \n            mergedResult.push(prevResult);\n        }\n        \n        if (currResult != null) {\n            mergedResult.push(currResult);\n        }\n\n\n        return mergedResult;\n    };\n\n    this.isAbleToMerge = function(text, result1, result2) {\n        var begin = result1.index + result1.text.length;\n        var end   = result2.index;\n        var textBetween = text.substring(begin,end);\n\n        return textBetween.match(this.pattern());\n    };\n\n    this.isWeekdayResult = function (result) {\n        return result.start.isCertain('weekday') && !result.start.isCertain('day');\n    };\n\n    this.mergeResult = function(text, fromResult, toResult) {\n\n        if (!this.isWeekdayResult(fromResult) && !this.isWeekdayResult(toResult)) {\n            \n            var timeKeys = {'hour': true, 'minute': true, 'second': true};\n\n            for (var key in toResult.start.knownValues) {\n                if (!fromResult.start.isCertain(key)) {\n                    fromResult.start.assign(key, toResult.start.get(key));\n                }\n            }\n\n            for (var key in fromResult.start.knownValues) {\n                if (!toResult.start.isCertain(key)) {\n                    toResult.start.assign(key, fromResult.start.get(key));\n                }\n            }\n        }\n\n        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {\n            \n            var fromMoment = fromResult.start.moment();\n            var toMoment = toResult.start.moment();\n\n            if (this.isWeekdayResult(fromResult) && fromMoment.clone().add(-7, 'days').isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-7, 'days');\n                fromResult.start.imply('day', fromMoment.date());\n                fromResult.start.imply('month', fromMoment.month() + 1);\n                fromResult.start.imply('year', fromMoment.year());\n            } else if (this.isWeekdayResult(toResult) && toMoment.clone().add(7, 'days').isAfter(fromMoment)) {\n                toMoment = toMoment.add(7, 'days');\n                toResult.start.imply('day', toMoment.date());\n                toResult.start.imply('month', toMoment.month() + 1);\n                toResult.start.imply('year', toMoment.year());\n            } else {\n                var tmp = toResult;\n                toResult = fromResult;\n                fromResult = tmp;\n            }\n        }\n        \n        fromResult.end = toResult.start;\n\n        \n\n        for (var tag in toResult.tags) {\n            fromResult.tags[tag] = true;\n        }\n\n            \n        var startIndex = Math.min(fromResult.index, toResult.index);\n        var endIndex = Math.max(\n            fromResult.index + fromResult.text.length, \n            toResult.index + toResult.text.length);\n            \n        fromResult.index = startIndex;\n        fromResult.text  = text.substring(startIndex, endIndex);\n        fromResult.tags[this.constructor.name] = true;\n        return fromResult;\n    }\n};\n\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

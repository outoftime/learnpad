{
  "ast": null,
  "code": "/*\r\n    \r\n*/\nvar ParsedComponents = require('../../result').ParsedComponents;\n\nvar Refiner = require('../refiner').Refiner;\n\nvar mergeDateTimeComponent = require('../en/ENMergeDateTimeRefiner').mergeDateTimeComponent;\n\nvar PATTERN = new RegExp(\"^\\\\s*(T|à|a|vers|de|,|-)?\\\\s*$\");\n\nfunction isDateOnly(result) {\n  return !result.start.isCertain('hour') || result.tags['FRCasualDateParser'];\n}\n\nfunction isTimeOnly(result) {\n  return !result.start.isCertain('month') && !result.start.isCertain('weekday');\n}\n\nfunction isAbleToMerge(text, prevResult, curResult) {\n  var textBetween = text.substring(prevResult.index + prevResult.text.length, curResult.index);\n  return textBetween.match(PATTERN);\n}\n\nfunction mergeResult(text, dateResult, timeResult) {\n  var beginDate = dateResult.start;\n  var beginTime = timeResult.start;\n  var beginDateTime = mergeDateTimeComponent(beginDate, beginTime);\n\n  if (dateResult.end != null || timeResult.end != null) {\n    var endDate = dateResult.end == null ? dateResult.start : dateResult.end;\n    var endTime = timeResult.end == null ? timeResult.start : timeResult.end;\n    var endDateTime = mergeDateTimeComponent(endDate, endTime);\n\n    if (dateResult.end == null && endDateTime.date().getTime() < beginDateTime.date().getTime()) {\n      // Ex. 9pm - 1am\n      if (endDateTime.isCertain('day')) {\n        endDateTime.assign('day', endDateTime.get('day') + 1);\n      } else {\n        endDateTime.imply('day', endDateTime.get('day') + 1);\n      }\n    }\n\n    dateResult.end = endDateTime;\n  }\n\n  dateResult.start = beginDateTime;\n  var startIndex = Math.min(dateResult.index, timeResult.index);\n  var endIndex = Math.max(dateResult.index + dateResult.text.length, timeResult.index + timeResult.text.length);\n  dateResult.index = startIndex;\n  dateResult.text = text.substring(startIndex, endIndex);\n\n  for (var tag in timeResult.tags) {\n    dateResult.tags[tag] = true;\n  }\n\n  dateResult.tags['FRMergeDateAndTimeRefiner'] = true;\n  return dateResult;\n}\n\nexports.Refiner = function FRMergeDateTimeRefiner() {\n  Refiner.call(this);\n\n  this.refine = function (text, results, opt) {\n    if (results.length < 2) return results;\n    var mergedResult = [];\n    var currResult = null;\n    var prevResult = null;\n\n    for (var i = 1; i < results.length; i++) {\n      currResult = results[i];\n      prevResult = results[i - 1];\n\n      if (isDateOnly(prevResult) && isTimeOnly(currResult) && isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = mergeResult(text, prevResult, currResult);\n        currResult = null;\n        i += 1;\n      } else if (isDateOnly(currResult) && isTimeOnly(prevResult) && isAbleToMerge(text, prevResult, currResult)) {\n        prevResult = mergeResult(text, currResult, prevResult);\n        currResult = null;\n        i += 1;\n      }\n\n      mergedResult.push(prevResult);\n    }\n\n    if (currResult != null) {\n      mergedResult.push(currResult);\n    }\n\n    return mergedResult;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/refiners/fr/FRMergeDateTimeRefiner.js"
    ],
    "names": [
      "ParsedComponents",
      "require",
      "Refiner",
      "mergeDateTimeComponent",
      "PATTERN",
      "RegExp",
      "isDateOnly",
      "result",
      "start",
      "isCertain",
      "tags",
      "isTimeOnly",
      "isAbleToMerge",
      "text",
      "prevResult",
      "curResult",
      "textBetween",
      "substring",
      "index",
      "length",
      "match",
      "mergeResult",
      "dateResult",
      "timeResult",
      "beginDate",
      "beginTime",
      "beginDateTime",
      "end",
      "endDate",
      "endTime",
      "endDateTime",
      "date",
      "getTime",
      "assign",
      "get",
      "imply",
      "startIndex",
      "Math",
      "min",
      "endIndex",
      "max",
      "tag",
      "exports",
      "FRMergeDateTimeRefiner",
      "call",
      "refine",
      "results",
      "opt",
      "mergedResult",
      "currResult",
      "i",
      "push"
    ],
    "mappings": "AAAA;;;AAGA,IAAIA,gBAAgB,GAAGC,OAAO,CAAC,cAAD,CAAP,CAAwBD,gBAA/C;;AACA,IAAIE,OAAO,GAAGD,OAAO,CAAC,YAAD,CAAP,CAAsBC,OAApC;;AACA,IAAIC,sBAAsB,GAAGF,OAAO,CAAC,8BAAD,CAAP,CAAwCE,sBAArE;;AAEA,IAAIC,OAAO,GAAG,IAAIC,MAAJ,CAAW,gCAAX,CAAd;;AAEA,SAASC,UAAT,CAAoBC,MAApB,EAA4B;AACxB,SAAO,CAACA,MAAM,CAACC,KAAP,CAAaC,SAAb,CAAuB,MAAvB,CAAD,IAAmCF,MAAM,CAACG,IAAP,CAAY,oBAAZ,CAA1C;AACH;;AAED,SAASC,UAAT,CAAoBJ,MAApB,EAA4B;AACxB,SAAO,CAACA,MAAM,CAACC,KAAP,CAAaC,SAAb,CAAuB,OAAvB,CAAD,IAAoC,CAACF,MAAM,CAACC,KAAP,CAAaC,SAAb,CAAuB,SAAvB,CAA5C;AACH;;AAGD,SAASG,aAAT,CAAuBC,IAAvB,EAA6BC,UAA7B,EAAyCC,SAAzC,EAAoD;AAChD,MAAIC,WAAW,GAAGH,IAAI,CAACI,SAAL,CAAeH,UAAU,CAACI,KAAX,GAAmBJ,UAAU,CAACD,IAAX,CAAgBM,MAAlD,EAA0DJ,SAAS,CAACG,KAApE,CAAlB;AACA,SAAOF,WAAW,CAACI,KAAZ,CAAkBhB,OAAlB,CAAP;AACH;;AAED,SAASiB,WAAT,CAAqBR,IAArB,EAA2BS,UAA3B,EAAuCC,UAAvC,EAAkD;AAE9C,MAAIC,SAAS,GAAGF,UAAU,CAACd,KAA3B;AACA,MAAIiB,SAAS,GAAGF,UAAU,CAACf,KAA3B;AACA,MAAIkB,aAAa,GAAGvB,sBAAsB,CAACqB,SAAD,EAAYC,SAAZ,CAA1C;;AAEA,MAAIH,UAAU,CAACK,GAAX,IAAkB,IAAlB,IAA0BJ,UAAU,CAACI,GAAX,IAAkB,IAAhD,EAAsD;AAElD,QAAIC,OAAO,GAAKN,UAAU,CAACK,GAAX,IAAkB,IAAlB,GAAyBL,UAAU,CAACd,KAApC,GAA4Cc,UAAU,CAACK,GAAvE;AACA,QAAIE,OAAO,GAAKN,UAAU,CAACI,GAAX,IAAkB,IAAlB,GAAyBJ,UAAU,CAACf,KAApC,GAA4Ce,UAAU,CAACI,GAAvE;AACA,QAAIG,WAAW,GAAG3B,sBAAsB,CAACyB,OAAD,EAAUC,OAAV,CAAxC;;AAEA,QAAIP,UAAU,CAACK,GAAX,IAAkB,IAAlB,IAA0BG,WAAW,CAACC,IAAZ,GAAmBC,OAAnB,KAA+BN,aAAa,CAACK,IAAd,GAAqBC,OAArB,EAA7D,EAA6F;AACzF;AACA,UAAIF,WAAW,CAACrB,SAAZ,CAAsB,KAAtB,CAAJ,EAAkC;AAC9BqB,QAAAA,WAAW,CAACG,MAAZ,CAAmB,KAAnB,EAA0BH,WAAW,CAACI,GAAZ,CAAgB,KAAhB,IAAyB,CAAnD;AACH,OAFD,MAEO;AACHJ,QAAAA,WAAW,CAACK,KAAZ,CAAkB,KAAlB,EAAyBL,WAAW,CAACI,GAAZ,CAAgB,KAAhB,IAAyB,CAAlD;AACH;AACJ;;AAEDZ,IAAAA,UAAU,CAACK,GAAX,GAAiBG,WAAjB;AACH;;AAEDR,EAAAA,UAAU,CAACd,KAAX,GAAmBkB,aAAnB;AAEA,MAAIU,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAShB,UAAU,CAACJ,KAApB,EAA2BK,UAAU,CAACL,KAAtC,CAAjB;AACA,MAAIqB,QAAQ,GAAGF,IAAI,CAACG,GAAL,CACPlB,UAAU,CAACJ,KAAX,GAAmBI,UAAU,CAACT,IAAX,CAAgBM,MAD5B,EAEPI,UAAU,CAACL,KAAX,GAAmBK,UAAU,CAACV,IAAX,CAAgBM,MAF5B,CAAf;AAIAG,EAAAA,UAAU,CAACJ,KAAX,GAAmBkB,UAAnB;AACAd,EAAAA,UAAU,CAACT,IAAX,GAAmBA,IAAI,CAACI,SAAL,CAAemB,UAAf,EAA2BG,QAA3B,CAAnB;;AAEA,OAAK,IAAIE,GAAT,IAAgBlB,UAAU,CAACb,IAA3B,EAAiC;AAC7BY,IAAAA,UAAU,CAACZ,IAAX,CAAgB+B,GAAhB,IAAuB,IAAvB;AACH;;AACDnB,EAAAA,UAAU,CAACZ,IAAX,CAAgB,2BAAhB,IAA+C,IAA/C;AACA,SAAOY,UAAP;AACH;;AAEDoB,OAAO,CAACxC,OAAR,GAAkB,SAASyC,sBAAT,GAAkC;AAChDzC,EAAAA,OAAO,CAAC0C,IAAR,CAAa,IAAb;;AAGA,OAAKC,MAAL,GAAc,UAAShC,IAAT,EAAeiC,OAAf,EAAwBC,GAAxB,EAA6B;AAEvC,QAAID,OAAO,CAAC3B,MAAR,GAAiB,CAArB,EAAwB,OAAO2B,OAAP;AAExB,QAAIE,YAAY,GAAG,EAAnB;AACA,QAAIC,UAAU,GAAG,IAAjB;AACA,QAAInC,UAAU,GAAG,IAAjB;;AAEA,SAAK,IAAIoC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAAC3B,MAA5B,EAAoC+B,CAAC,EAArC,EAAyC;AAErCD,MAAAA,UAAU,GAAGH,OAAO,CAACI,CAAD,CAApB;AACApC,MAAAA,UAAU,GAAGgC,OAAO,CAACI,CAAC,GAAC,CAAH,CAApB;;AAEA,UAAI5C,UAAU,CAACQ,UAAD,CAAV,IAA0BH,UAAU,CAACsC,UAAD,CAApC,IACOrC,aAAa,CAACC,IAAD,EAAOC,UAAP,EAAmBmC,UAAnB,CADxB,EACwD;AAEpDnC,QAAAA,UAAU,GAAGO,WAAW,CAACR,IAAD,EAAOC,UAAP,EAAmBmC,UAAnB,CAAxB;AACAA,QAAAA,UAAU,GAAG,IAAb;AACAC,QAAAA,CAAC,IAAI,CAAL;AAEH,OAPD,MAOO,IAAI5C,UAAU,CAAC2C,UAAD,CAAV,IAA0BtC,UAAU,CAACG,UAAD,CAApC,IACAF,aAAa,CAACC,IAAD,EAAOC,UAAP,EAAmBmC,UAAnB,CADjB,EACiD;AAEpDnC,QAAAA,UAAU,GAAGO,WAAW,CAACR,IAAD,EAAOoC,UAAP,EAAmBnC,UAAnB,CAAxB;AACAmC,QAAAA,UAAU,GAAG,IAAb;AACAC,QAAAA,CAAC,IAAI,CAAL;AACH;;AAEDF,MAAAA,YAAY,CAACG,IAAb,CAAkBrC,UAAlB;AACH;;AAED,QAAImC,UAAU,IAAI,IAAlB,EAAwB;AACpBD,MAAAA,YAAY,CAACG,IAAb,CAAkBF,UAAlB;AACH;;AAED,WAAOD,YAAP;AACH,GApCD;AAqCH,CAzCD",
    "sourcesContent": [
      "/*\r\n    \r\n*/\r\nvar ParsedComponents = require('../../result').ParsedComponents;\r\nvar Refiner = require('../refiner').Refiner;\r\nvar mergeDateTimeComponent = require('../en/ENMergeDateTimeRefiner').mergeDateTimeComponent;\r\n\r\nvar PATTERN = new RegExp(\"^\\\\s*(T|à|a|vers|de|,|-)?\\\\s*$\");\r\n\r\nfunction isDateOnly(result) {\r\n    return !result.start.isCertain('hour') || result.tags['FRCasualDateParser'];\r\n}\r\n    \r\nfunction isTimeOnly(result) {\r\n    return !result.start.isCertain('month') && !result.start.isCertain('weekday');\r\n}\r\n\r\n\r\nfunction isAbleToMerge(text, prevResult, curResult) {\r\n    var textBetween = text.substring(prevResult.index + prevResult.text.length, curResult.index);\r\n    return textBetween.match(PATTERN);\r\n}\r\n\r\nfunction mergeResult(text, dateResult, timeResult){\r\n\r\n    var beginDate = dateResult.start;\r\n    var beginTime = timeResult.start;\r\n    var beginDateTime = mergeDateTimeComponent(beginDate, beginTime);\r\n\r\n    if (dateResult.end != null || timeResult.end != null) {\r\n        \r\n        var endDate   = dateResult.end == null ? dateResult.start : dateResult.end;            \r\n        var endTime   = timeResult.end == null ? timeResult.start : timeResult.end;\r\n        var endDateTime = mergeDateTimeComponent(endDate, endTime);\r\n        \r\n        if (dateResult.end == null && endDateTime.date().getTime() < beginDateTime.date().getTime()) {\r\n            // Ex. 9pm - 1am\r\n            if (endDateTime.isCertain('day')) {\r\n                endDateTime.assign('day', endDateTime.get('day') + 1);\r\n            } else {\r\n                endDateTime.imply('day', endDateTime.get('day') + 1);\r\n            }\r\n        }\r\n\r\n        dateResult.end = endDateTime;\r\n    }\r\n\r\n    dateResult.start = beginDateTime;    \r\n\r\n    var startIndex = Math.min(dateResult.index, timeResult.index);\r\n    var endIndex = Math.max(\r\n            dateResult.index + dateResult.text.length, \r\n            timeResult.index + timeResult.text.length);\r\n    \r\n    dateResult.index = startIndex;\r\n    dateResult.text  = text.substring(startIndex, endIndex);\r\n\r\n    for (var tag in timeResult.tags) {\r\n        dateResult.tags[tag] = true;\r\n    }\r\n    dateResult.tags['FRMergeDateAndTimeRefiner'] = true;\r\n    return dateResult;\r\n}\r\n\r\nexports.Refiner = function FRMergeDateTimeRefiner() {\r\n    Refiner.call(this);\r\n\r\n\r\n    this.refine = function(text, results, opt) { \r\n\r\n        if (results.length < 2) return results;\r\n\r\n        var mergedResult = [];\r\n        var currResult = null;\r\n        var prevResult = null;\r\n\r\n        for (var i = 1; i < results.length; i++) {\r\n\r\n            currResult = results[i];\r\n            prevResult = results[i-1];\r\n            \r\n            if (isDateOnly(prevResult) && isTimeOnly(currResult) \r\n                    && isAbleToMerge(text, prevResult, currResult)) {\r\n                \r\n                prevResult = mergeResult(text, prevResult, currResult);\r\n                currResult = null;\r\n                i += 1;\r\n                \r\n            } else if (isDateOnly(currResult) && isTimeOnly(prevResult)\r\n                    && isAbleToMerge(text, prevResult, currResult)) {\r\n                \r\n                prevResult = mergeResult(text, currResult, prevResult);\r\n                currResult = null;\r\n                i += 1;\r\n            }\r\n            \r\n            mergedResult.push(prevResult);\r\n        }\r\n\r\n        if (currResult != null) {\r\n            mergedResult.push(currResult);\r\n        }\r\n\r\n        return mergedResult;\r\n    }\r\n}"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}

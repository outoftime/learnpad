{
  "ast": null,
  "code": "/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n/*\n  Valid patterns:\n  - esta mañana -> today in the morning\n  - esta tarde -> today in the afternoon/evening\n  - esta noche -> tonight\n  - ayer por la mañana -> yesterday in the morning\n  - ayer por la tarde -> yesterday in the afternoon/evening\n  - ayer por la noche -> yesterday at night\n  - mañana por la mañana -> tomorrow in the morning\n  - mañana por la tarde -> tomorrow in the afternoon/evening\n  - mañana por la noche -> tomorrow at night\n  - anoche -> tomorrow at night\n  - hoy -> today\n  - ayer -> yesterday\n  - mañana -> tomorrow\n */\n\n\nvar PATTERN = /(\\W|^)(ahora|esta\\s*(mañana|tarde|noche)|(ayer|mañana)\\s*por\\s*la\\s*(mañana|tarde|noche)|hoy|mañana|ayer|anoche)(?=\\W|$)/i;\n\nexports.Parser = function ESCasualDateParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var text = match[0].substr(match[1].length);\n    var index = match.index + match[1].length;\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var refMoment = moment(ref);\n    var startMoment = refMoment.clone();\n    var lowerText = text.toLowerCase().replace(/\\s+/g, ' ');\n\n    if (lowerText == 'mañana') {\n      // Check not \"Tomorrow\" on late night\n      if (refMoment.hour() > 1) {\n        startMoment.add(1, 'day');\n      }\n    } else if (lowerText == 'ayer') {\n      startMoment.add(-1, 'day');\n    } else if (lowerText == 'anoche') {\n      result.start.imply('hour', 0);\n\n      if (refMoment.hour() > 6) {\n        startMoment.add(-1, 'day');\n      }\n    } else if (lowerText.match(\"esta\")) {\n      var secondMatch = match[3].toLowerCase();\n\n      if (secondMatch == \"tarde\") {\n        result.start.imply('hour', 18);\n      } else if (secondMatch == \"mañana\") {\n        result.start.imply('hour', 6);\n      } else if (secondMatch == \"noche\") {\n        // Normally means this coming midnight\n        result.start.imply('hour', 22);\n        result.start.imply('meridiem', 1);\n      }\n    } else if (lowerText.match(/por\\s*la/)) {\n      var firstMatch = match[4].toLowerCase();\n\n      if (firstMatch === 'ayer') {\n        startMoment.add(-1, 'day');\n      } else if (firstMatch === 'mañana') {\n        startMoment.add(1, 'day');\n      }\n\n      var secondMatch = match[5].toLowerCase();\n\n      if (secondMatch == \"tarde\") {\n        result.start.imply('hour', 18);\n      } else if (secondMatch == \"mañana\") {\n        result.start.imply('hour', 9);\n      } else if (secondMatch == \"noche\") {\n        // Normally means this coming midnight\n        result.start.imply('hour', 22);\n        result.start.imply('meridiem', 1);\n      }\n    } else if (lowerText.match(\"ahora\")) {\n      result.start.imply('hour', refMoment.hour());\n      result.start.imply('minute', refMoment.minute());\n      result.start.imply('second', refMoment.second());\n      result.start.imply('millisecond', refMoment.millisecond());\n    }\n\n    result.start.assign('day', startMoment.date());\n    result.start.assign('month', startMoment.month() + 1);\n    result.start.assign('year', startMoment.year());\n    result.tags['ESCasualDateParser'] = true;\n    return result;\n  };\n};",
  "map": {
    "version": 3,
    "sources": [
      "/Users/peter/Desktop/code/popcode/node_modules/chrono-node/src/parsers/es/ESCasualDateParser.js"
    ],
    "names": [
      "moment",
      "require",
      "Parser",
      "ParsedResult",
      "PATTERN",
      "exports",
      "ESCasualDateParser",
      "apply",
      "arguments",
      "pattern",
      "extract",
      "text",
      "ref",
      "match",
      "opt",
      "substr",
      "length",
      "index",
      "result",
      "refMoment",
      "startMoment",
      "clone",
      "lowerText",
      "toLowerCase",
      "replace",
      "hour",
      "add",
      "start",
      "imply",
      "secondMatch",
      "firstMatch",
      "minute",
      "second",
      "millisecond",
      "assign",
      "date",
      "month",
      "year",
      "tags"
    ],
    "mappings": "AAAA;;;;AAKA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAP,CAAqBC,MAAlC;;AACA,IAAIC,YAAY,GAAGF,OAAO,CAAC,cAAD,CAAP,CAAwBE,YAA3C;AAEA;;;;;;;;;;;;;;;;;;AAgBA,IAAIC,OAAO,GAAG,2HAAd;;AAEAC,OAAO,CAACH,MAAR,GAAiB,SAASI,kBAAT,GAA6B;AAE1CJ,EAAAA,MAAM,CAACK,KAAP,CAAa,IAAb,EAAmBC,SAAnB;;AAEA,OAAKC,OAAL,GAAe,YAAW;AAAE,WAAOL,OAAP;AAAiB,GAA7C;;AAEA,OAAKM,OAAL,GAAe,UAASC,IAAT,EAAeC,GAAf,EAAoBC,KAApB,EAA2BC,GAA3B,EAA+B;AAE1C,QAAIH,IAAI,GAAGE,KAAK,CAAC,CAAD,CAAL,CAASE,MAAT,CAAgBF,KAAK,CAAC,CAAD,CAAL,CAASG,MAAzB,CAAX;AACA,QAAIC,KAAK,GAAGJ,KAAK,CAACI,KAAN,GAAcJ,KAAK,CAAC,CAAD,CAAL,CAASG,MAAnC;AACA,QAAIE,MAAM,GAAG,IAAIf,YAAJ,CAAiB;AAC1Bc,MAAAA,KAAK,EAAEA,KADmB;AAE1BN,MAAAA,IAAI,EAAEA,IAFoB;AAG1BC,MAAAA,GAAG,EAAEA;AAHqB,KAAjB,CAAb;AAMA,QAAIO,SAAS,GAAGnB,MAAM,CAACY,GAAD,CAAtB;AACA,QAAIQ,WAAW,GAAGD,SAAS,CAACE,KAAV,EAAlB;AACA,QAAIC,SAAS,GAAGX,IAAI,CAACY,WAAL,GAAmBC,OAAnB,CAA2B,MAA3B,EAAmC,GAAnC,CAAhB;;AAEA,QAAGF,SAAS,IAAI,QAAhB,EAAyB;AAErB;AACA,UAAGH,SAAS,CAACM,IAAV,KAAmB,CAAtB,EAAyB;AACrBL,QAAAA,WAAW,CAACM,GAAZ,CAAgB,CAAhB,EAAmB,KAAnB;AACH;AAEJ,KAPD,MAOO,IAAGJ,SAAS,IAAI,MAAhB,EAAwB;AAE3BF,MAAAA,WAAW,CAACM,GAAZ,CAAgB,CAAC,CAAjB,EAAoB,KAApB;AACH,KAHM,MAIF,IAAGJ,SAAS,IAAI,QAAhB,EAA0B;AAE3BJ,MAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,CAA3B;;AACA,UAAIT,SAAS,CAACM,IAAV,KAAmB,CAAvB,EAA0B;AACtBL,QAAAA,WAAW,CAACM,GAAZ,CAAgB,CAAC,CAAjB,EAAoB,KAApB;AACH;AAEJ,KAPI,MAOE,IAAIJ,SAAS,CAACT,KAAV,CAAgB,MAAhB,CAAJ,EAA6B;AAEhC,UAAIgB,WAAW,GAAGhB,KAAK,CAAC,CAAD,CAAL,CAASU,WAAT,EAAlB;;AACA,UAAIM,WAAW,IAAI,OAAnB,EAA4B;AAExBX,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AAEH,OAJD,MAIO,IAAIC,WAAW,IAAI,QAAnB,EAA6B;AAEhCX,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,CAA3B;AAEH,OAJM,MAIA,IAAIC,WAAW,IAAI,OAAnB,EAA4B;AAEjC;AACAX,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AACAV,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,UAAnB,EAA+B,CAA/B;AAED;AACJ,KAlBM,MAkBA,IAAIN,SAAS,CAACT,KAAV,CAAgB,UAAhB,CAAJ,EAAiC;AAEpC,UAAIiB,UAAU,GAAGjB,KAAK,CAAC,CAAD,CAAL,CAASU,WAAT,EAAjB;;AACA,UAAIO,UAAU,KAAK,MAAnB,EAA2B;AAEzBV,QAAAA,WAAW,CAACM,GAAZ,CAAgB,CAAC,CAAjB,EAAoB,KAApB;AAED,OAJD,MAIO,IAAII,UAAU,KAAK,QAAnB,EAA6B;AAElCV,QAAAA,WAAW,CAACM,GAAZ,CAAgB,CAAhB,EAAmB,KAAnB;AAED;;AAED,UAAIG,WAAW,GAAGhB,KAAK,CAAC,CAAD,CAAL,CAASU,WAAT,EAAlB;;AACA,UAAIM,WAAW,IAAI,OAAnB,EAA4B;AAExBX,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AAEH,OAJD,MAIO,IAAIC,WAAW,IAAI,QAAnB,EAA6B;AAEhCX,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,CAA3B;AAEH,OAJM,MAIA,IAAIC,WAAW,IAAI,OAAnB,EAA4B;AAEjC;AACAX,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2B,EAA3B;AACAV,QAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,UAAnB,EAA+B,CAA/B;AAED;AAEJ,KA9BM,MA8BA,IAAIN,SAAS,CAACT,KAAV,CAAgB,OAAhB,CAAJ,EAA8B;AAEnCK,MAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,MAAnB,EAA2BT,SAAS,CAACM,IAAV,EAA3B;AACAP,MAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,QAAnB,EAA6BT,SAAS,CAACY,MAAV,EAA7B;AACAb,MAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,QAAnB,EAA6BT,SAAS,CAACa,MAAV,EAA7B;AACAd,MAAAA,MAAM,CAACS,KAAP,CAAaC,KAAb,CAAmB,aAAnB,EAAkCT,SAAS,CAACc,WAAV,EAAlC;AAED;;AAEDf,IAAAA,MAAM,CAACS,KAAP,CAAaO,MAAb,CAAoB,KAApB,EAA2Bd,WAAW,CAACe,IAAZ,EAA3B;AACAjB,IAAAA,MAAM,CAACS,KAAP,CAAaO,MAAb,CAAoB,OAApB,EAA6Bd,WAAW,CAACgB,KAAZ,KAAsB,CAAnD;AACAlB,IAAAA,MAAM,CAACS,KAAP,CAAaO,MAAb,CAAoB,MAApB,EAA4Bd,WAAW,CAACiB,IAAZ,EAA5B;AACAnB,IAAAA,MAAM,CAACoB,IAAP,CAAY,oBAAZ,IAAoC,IAApC;AACA,WAAOpB,MAAP;AACH,GA9FD;AA+FH,CArGD",
    "sourcesContent": [
      "/*\n\n\n*/\n\nvar moment = require('moment');\nvar Parser = require('../parser').Parser;\nvar ParsedResult = require('../../result').ParsedResult;\n\n/*\n  Valid patterns:\n  - esta mañana -> today in the morning\n  - esta tarde -> today in the afternoon/evening\n  - esta noche -> tonight\n  - ayer por la mañana -> yesterday in the morning\n  - ayer por la tarde -> yesterday in the afternoon/evening\n  - ayer por la noche -> yesterday at night\n  - mañana por la mañana -> tomorrow in the morning\n  - mañana por la tarde -> tomorrow in the afternoon/evening\n  - mañana por la noche -> tomorrow at night\n  - anoche -> tomorrow at night\n  - hoy -> today\n  - ayer -> yesterday\n  - mañana -> tomorrow\n */\nvar PATTERN = /(\\W|^)(ahora|esta\\s*(mañana|tarde|noche)|(ayer|mañana)\\s*por\\s*la\\s*(mañana|tarde|noche)|hoy|mañana|ayer|anoche)(?=\\W|$)/i;\n\nexports.Parser = function ESCasualDateParser(){\n\n    Parser.apply(this, arguments);\n\n    this.pattern = function() { return PATTERN; }\n\n    this.extract = function(text, ref, match, opt){\n\n        var text = match[0].substr(match[1].length);\n        var index = match.index + match[1].length;\n        var result = new ParsedResult({\n            index: index,\n            text: text,\n            ref: ref,\n        });\n\n        var refMoment = moment(ref);\n        var startMoment = refMoment.clone();\n        var lowerText = text.toLowerCase().replace(/\\s+/g, ' ');\n\n        if(lowerText == 'mañana'){\n\n            // Check not \"Tomorrow\" on late night\n            if(refMoment.hour() > 1) {\n                startMoment.add(1, 'day');\n            }\n\n        } else if(lowerText == 'ayer') {\n\n            startMoment.add(-1, 'day');\n        }\n        else if(lowerText == 'anoche') {\n\n            result.start.imply('hour', 0);\n            if (refMoment.hour() > 6) {\n                startMoment.add(-1, 'day');\n            }\n\n        } else if (lowerText.match(\"esta\")) {\n\n            var secondMatch = match[3].toLowerCase();\n            if (secondMatch == \"tarde\") {\n\n                result.start.imply('hour', 18);\n\n            } else if (secondMatch == \"mañana\") {\n\n                result.start.imply('hour', 6);\n\n            } else if (secondMatch == \"noche\") {\n\n              // Normally means this coming midnight\n              result.start.imply('hour', 22);\n              result.start.imply('meridiem', 1);\n\n            }\n        } else if (lowerText.match(/por\\s*la/)) {\n\n            var firstMatch = match[4].toLowerCase();\n            if (firstMatch === 'ayer') {\n\n              startMoment.add(-1, 'day');\n\n            } else if (firstMatch === 'mañana') {\n\n              startMoment.add(1, 'day');\n\n            }\n\n            var secondMatch = match[5].toLowerCase();\n            if (secondMatch == \"tarde\") {\n\n                result.start.imply('hour', 18);\n\n            } else if (secondMatch == \"mañana\") {\n\n                result.start.imply('hour', 9);\n\n            } else if (secondMatch == \"noche\") {\n\n              // Normally means this coming midnight\n              result.start.imply('hour', 22);\n              result.start.imply('meridiem', 1);\n\n            }\n\n        } else if (lowerText.match(\"ahora\")) {\n\n          result.start.imply('hour', refMoment.hour());\n          result.start.imply('minute', refMoment.minute());\n          result.start.imply('second', refMoment.second());\n          result.start.imply('millisecond', refMoment.millisecond());\n\n        }\n\n        result.start.assign('day', startMoment.date())\n        result.start.assign('month', startMoment.month() + 1)\n        result.start.assign('year', startMoment.year())\n        result.tags['ESCasualDateParser'] = true;\n        return result;\n    }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
